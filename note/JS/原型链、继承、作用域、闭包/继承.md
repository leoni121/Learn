[TOC]

## 1. 原型链继承 ##

```js
function Person(name){
 this.name=name;
 this.className="person" 
}
Person.prototype.getClassName=function(){
 console.log(this.className)
}

function Man(){
}
Man.prototype=new Person();//1
Man.prototype=Man;

//Man.prototype=new Person("Davin");//2
var man=new Man;
man.getClassName()
// "person"
man instanceof Person
// true
```

## 2. 构造函数继承 ##

```js
function Person(name){
 this.name=name;
 this.className="person" 
}
Person.prototype.getName=function(){
 console.log(this.name)
}

function Man(name){
  Person.apply(this,arguments)
}

var man1=new Man("Davin");
var man2=new Man("Jack");
man1.name
// "Davin"
man2.name
// "Jack"
man1.getName() //1 报错
man1 instanceof Person // false	
>true
```

## 3. 组合继承 ##

```js
function Person(name){
 this.name=name||"default name"; //1
 this.className="person" 
}
Person.prototype.getName=function(){
 console.log(this.name)
}
function Man(name){
  Person.apply(this,arguments)
}
//继承原型
Man.prototype = new Person();
var man1=new Man("Davin");
> man1.name
>"Davin"
> man1.getName()
>"Davin"

```

## 4. 寄生组合继承 ##

```js
function Person(name){
 this.name=name; //1
 this.className="person" 
}
Person.prototype.getName=function(){
 console.log(this.name)
}
function Man(name){
  Person.apply(this,arguments)
}
//注意此处
Man.prototype = Object.create(Person.prototype);
var man1=new Man("Davin");
man1.name
// "Davin"
man1.getName()
// "Davin"
```

## 5. ES6  ##

```JS
class A {
}

class B extends A {
}

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
```

**Class 实现**

1. _classCallCheck，检测 当前 class 的调用方式

2. _createClass

   `defineProperties`

   * 非静态方法定义在原型链上
   * 静态方法直接定义在constructor函数上

3. 返回

**继承**

1. _inherits

   ```js
   B.__proto__ === A // true
   B.prototype.__proto__ === A.prototype // true
   ```

2. _classCallCheck，检测 当前 class 的调用方式

3. _createClass

   `defineProperties`

   - 非静态方法定义在原型链上
   - 静态方法直接定义在constructor函数上

4. 返回