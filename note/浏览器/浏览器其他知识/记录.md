[TOC]

## 1. 浏览器并行下载相关 ##

### 1.1 `DNS`查找 ###

一个页面所需要访问的域名数量为n，那么就需要n次DNS查找，而**DNS查找通常是blocking call，**就是说在得到结果之后才能继续，所以越多的DNS查找，反应速度就越慢。

### 1.2 并发请求数 ###

[参考-博客](https://www.jianshu.com/p/8a86f414a69e)

**同一时间针对同一域名下的请求有一定数量限制**。超过限制数目的请求会被阻止。浏览器的并发数目一般限制在10以内,HTTP1.1 比 HTTP1.0 并发链接量高

### 1.3 网页效率之DNS查找和并行下载 ###

[参考-博客](https://blog.csdn.net/21aspnet/article/details/6570449)

English：Reducing the number of unique hostnames has the potential to reduce the amount of parallel downloading that takes place in the page. Avoiding DNS lookups cuts response times, but reducing parallel downloads may increase response times. ***My guideline is to split these components across at least two but no more than four hostnames. This results in a good compromise between reducing DNS lookups and allowing a high degree of parallel downloads.***

中文：减少唯一主机名的数量有可能减少页面中并行下载的数量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的指导方针是将这些组件拆分为***至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间产生了很好的折衷。***

### 1.4 并行下载 ###

**连接数** = 不同域名的**主机数**（最好至少两个但不超过四个主机名） 服务器允许的**最大连接数**（或浏览器单个域名的最大请求数）

**下载数** = **连接数** * 每个连接内部的**流水线请求数**

> * 前提是服务器支持***persistent connection***-持久连接，比如在Apache设置KeepAlive为On
>
> * **流水线请求**：在一个TCP连接内，多个HTTP请求可以并行，**下一个HTTP请求在上一个HTTP请求的应答完成之前就发起。**
> * 对服务器和浏览器来说，一个连接里多个流水线请求能够比多个并行连接更好些
> * 浏览器所允许的最多连接数,由**浏览器所允许最多连接数**(network.http.max-connections，缺省为24)，**和每个服务器所允许的最大连接数**(network.http.max-connections-per-server，缺省为8)决定。

## 2. 跨域 — ***No 'Access-Control-Allow-Origin' header is present on the requested resource.*** ##

[**详解跨域(最全的解决方案)**](<https://www.imooc.com/article/21976>)

### 2.1 什么是跨域？ ###

访问同源的资源是被浏览器允许的，但是如果访问不同源（**同源是指，域名、协议、端口均为相同**）的资源，浏览器默认是不允许的。**访问不同源的资源那就是我们所说的跨域**

> 跨域限制主要的目的就是为了用户的上网安全。

### 2.2 什么是浏览器同源策略 ###

同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

它的核心就在于**它认为站点装载的任何内容都是不安全的。当浏览器半信半疑的将脚本在沙箱运行时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。**

同源策略又分为以下两种：

1. ***DOM 同源策略***：禁止对不同源页面 DOM 进行操作。这里主要场景是 **iframe 跨域的情况**，不同域名的 iframe 是限制互相访问的。
2. ***XMLHttpRequest 同源策略***：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。

### 2.3 同源策略如何保护用户数据安全？没有同源策略会怎么样？ ###

[参考](https://www.jianshu.com/p/2547b0a15707)

**（1） 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB 无法读取。**

防止恶意网站通过js获取用户其他网站的cookie。

**（2） 无法用js获取非同源的DOM 。**

如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。

**（3） 无法用js发送非同源的AJAX请求 。**

下面的例子是来自[CSDN的一篇博客](<https://blog.csdn.net/hcrw01/article/details/84289109>)

> 假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。
>  为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。
>  于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。
>  如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！

### 2.4 跨域的解决办法 ###

1. jsonp跨域
   jsonp跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信

   ```js
   //原生的实现方式
   let script = document.createElement('script');
   script.type = "text/javascript";
   script.src = 'http://www.nealyang.cn/login?username=Nealyang&callback=callback';
   document.body.appendChild(script);
   ```

2. document.domain + iframe 跨域

   这种跨域的方式最主要的是要求主域名相同。什么是主域名相同呢？
   `www.geekjc.com  aaa.geekjc.com ba.ad.geekjc.com `这三个主域名都是geekjc.com,而主域名不同的就不能用此方法。

   ```js
   document.domain = 'geekjc.com'
   ```

3. window.name + iframe 跨域

4. location.hash + iframe 跨域

5. postMessage跨域这是由H5提出来的一个炫酷的API，IE8+，chrome,ff都已经支持实现了这个功能。这个功能也是非常的简单，其中包括接受信息的Message事件，和发送信息的postMessage方法。

   发送信息的postMessage方法是向外界窗口发送信息

   ```js
   // 发送
   otherWindow.postMessage(message,targetOrigin);
   
   // 接受
   var onmessage = function(event) {
     var data = event.data;
     var origin = event.origin;
   }
   if(typeof window.addEventListener != 'undefined'){
     window.addEventListener('message',onmessage,false);
   }else if(typeof window.attachEvent != 'undefined'){
       window.attachEvent('onmessage', onmessage);
   }
   ```

6. 跨域资源共享 CORS
   [CORS 跨域资源共享](<https://blog.haoduoyu.cc/2016/11/20/CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/>)

   **CORS（Cross-Origin Resource Sharing，跨域资源共享）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应的成功和失败。**

   CORS 需要浏览器和服务器同时支持。目前，大部分浏览器都支持该功能 [(浏览器支持情况)](http://caniuse.com/#search=cors)。CORS 通信与同源的 AJAX 通信没有差别。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。

   > **错误捕获**：如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。

7. WebSocket协议跨域

   WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。

   原生WebSocket API使用起来不太方便，[我们使用Socket.io](http://xn--socket-hz8ig3bo82im51b.io/)，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

8. node代理跨域

## 3. 浏览器缓存机制 ##

### 3.1 强制缓存 ###

> 强制缓存(size: from disk cache)、对比缓存(status: 304)。
>
> 缓存规则信息包含在响应header

（1）强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。

（2）对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires、Cache-Control）

* ***Expires***的值为**服务端返回的到期时间**，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。
* Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
  * private: 客户端可以缓存
  * public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
  * max-age=xxx: 缓存的内容将在 xxx 秒后失效
  * no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）
  * no-store:  **所有内容都不会缓存，强制缓存，对比缓存都不会触发**（对于前端开发来说，缓存越多越好，so...基本上和它说886）

### 3.2 协商缓存 ###

（1）对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。

* Last-Modified(response header) / If-Modified-Since(request header用来发送last-modified)
* Etag(服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）) / If-None-Match(发送Etag)。（优先级高于Last-Modified  /  If-Modified-Since）