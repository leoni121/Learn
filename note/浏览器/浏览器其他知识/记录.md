[TOC]

## 1. 浏览器并行下载相关 ##

### 1.1 `DNS`查找 ###

一个页面所需要访问的域名数量为n，那么就需要n次DNS查找，而DNS查找通常是blocking call，就是说在得到结果之后才能继续，所以越多的DNS查找，反应速度就越慢。

### 1.2 并发请求数 ###

[参考-博客](https://www.jianshu.com/p/8a86f414a69e)

同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。浏览器的并发数目一般限制在10以内,HTTP1.1 比 HTTP1.0 并发链接量高

### 1.3 网页效率之DNS查找和并行下载 ###

[参考-博客](https://blog.csdn.net/21aspnet/article/details/6570449)

English：Reducing the number of unique hostnames has the potential to reduce the amount of parallel downloading that takes place in the page. Avoiding DNS lookups cuts response times, but reducing parallel downloads may increase response times. ***My guideline is to split these components across at least two but no more than four hostnames. This results in a good compromise between reducing DNS lookups and allowing a high degree of parallel downloads.***

中文：减少唯一主机名的数量有可能减少页面中并行下载的数量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的指导方针是将这些组件拆分为至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间产生了很好的折衷。

### 1.4 并行下载 ###

连接数 = 不同域名的主机数（最好至少两个但不超过四个主机名） * 服务器允许的最大连接数（或浏览器单个域名的最大请求数）

下载数 = 连接数 * 每个连接内部的流水线请求数

> 前提是服务器支持***persistent connection***-持久连接
>
> 比如在Apache设置KeepAlive为On

 并行下载(parallel downloading)由两个因素决定：

1. 到服务器的连接数量，以及每个连接内部的流水线请求数量。

2. 服务器的连接数量由两个因素决定：

   1. 页面所需访问的域名数量，和浏览器单个域名允许的最多连接数——同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止，一般不超过10 

      > [参考 1.2 ](#1.2 并发请求数)

   2. 浏览器所允许的最多连接数,由浏览器所允许最多连接数(network.http.max-connections，缺省为24)，和每个服务器所允许的最大连接数(network.http.max-connections-per-server，缺省为8)决定。

> 对服务器和浏览器来说，一个连接里多个流水线请求能够比多个并行连接更好些

## 2. 跨域 — ***No 'Access-Control-Allow-Origin' header is present on the requested resource.*** ##

[参考-博客](<https://www.imooc.com/article/21976>)

### 2.1 什么是跨域？ ###

访问同源的资源是被浏览器允许的，但是如果访问不同源的资源，浏览器默认是不允许的。访问不同源的资源那就是我们所说的跨域

> 跨域限制主要的目的就是为了用户的上网安全。

### 2.2 什么是浏览器同源策略 ###

同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

它的核心就在于它认为任何站点装载的内容是不安全的。当浏览器半信半疑的脚本在沙箱运行时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。

> 同源是指：域名、协议、端口相同

同源策略又分为以下两种：

1. ***DOM 同源策略***：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。
2. ***XMLHttpRequest 同源策略***：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。

### 2.3 同源策略如何保护用户数据安全？没有同源策略会怎么样？ ###

[参考](https://www.jianshu.com/p/2547b0a15707)

**（1） 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB 无法读取。**

这条很好理解。为了防止恶意网站通过js获取用户其他网站的cookie。

**（2） 无法用js获取非同源的DOM 。**

如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。

**（3） 无法用js发送非同源的AJAX请求 。**

这一条我一开始也没搞懂为什么。如果没有这一条会有什么危害？
 看了这篇文章后我终于懂了<https://blog.csdn.net/hcrw01/article/details/84289109>
 我把这部分复制过来放在这里。

> 假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。
>  为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。
>  于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。
>  如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！

### 2.4 跨域的解决办法 ###

1. jsonp跨域
   jsonp跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信

   ```js
   //原生的实现方式
   let script = document.createElement('script');
   script.type = "text/javascript";
   script.src = 'http://www.nealyang.cn/login?username=Nealyang&callback=callback';
   document.body.appendChild(script);
   ```

2. document.domain + iframe 跨域

   这种跨域的方式最主要的是要求主域名相同。什么是主域名相同呢？
   `www.geekjc.com  aaa.geekjc.com ba.ad.geekjc.com `这三个主域名都是geekjc.com,而主域名不同的就不能用此方法。

   ```js
   document.domain = 'geekjc.com'
   ```

3. window.name + iframe 跨域

4. location.hash + iframe 跨域

5. postMessage跨域这是由H5提出来的一个炫酷的API，IE8+，chrome,ff都已经支持实现了这个功能。这个功能也是非常的简单，其中包括接受信息的Message事件，和发送信息的postMessage方法。

   发送信息的postMessage方法是向外界窗口发送信息

   ```js
   // 发送
   otherWindow.postMessage(message,targetOrigin);
   
   // 接受
   var onmessage = function(event) {
     var data = event.data;
     var origin = event.origin;
   }
   
   if(typeof window.addEventListener != 'undefined'){
       window.addEventListener('message',onmessage,false);
   }else if(typeof window.attachEvent != 'undefined'){
       window.attachEvent('onmessage', onmessage);
   }
   ```

6. 跨域资源共享 CORS

   **简介**

   CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

   CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。

   整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
   

7. WebSocket协议跨域

   WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。

   原生WebSocket API使用起来不太方便，[我们使用Socket.io](http://xn--socket-hz8ig3bo82im51b.io/)，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
   

8. node代理跨域