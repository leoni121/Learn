# 一、参考

[网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？](https://www.zhihu.com/question/31809713/answer/53544875)

[第 32 题：Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/47#) 

# 二、Get

1. 没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 **DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的**

   > 框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能

2. **不管你的数据变化多少，每次重绘的性能都可以接受**，**可以以最小的代价来更新 DOM（`diff`）**；你依然可以用类似 innerHTML 的思路去写你的应用

   > * innerHTML 的总计算量，不管是 **js 计算还是 DOM 操作**都是和**整个界面的大小**相关
   > *  Virtual DOM 的计算量，只有 **js 计算和界面大小相关**，**DOM 操作是和数据的变动量相关**。

3. 掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易**维护**

4. **大型**项目，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，**不能保证每个人都有手工优化的能力。**

5. 为**函数式的 UI** 编程方式打开了大门

6. 可以渲染到 DOM 以外的 backend，比如 ReactNative。作为一个抽象层，方便向没有 DOM 接口的原生应用**平台移植**。

7. **virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。**



# 三、直接操作 DOM 性能差	

[前端为什么操作 DOM 是最耗性能的呢？](https://www.zhihu.com/question/324992717/answer/690011952)

1. 为了让 **Web 编程模型**保持简单，浏览器的 **JavaScript 引擎**与 **DOM 引擎**共享一个**主线程**。任何 **DOM API 调用**都要先将 JS 数据结构转为 DOM 数据结构，再挂起 JS 引擎并启动 DOM 引擎，执行过后再把可能的返回值反转数据结构，重启 JS 引擎继续执行。这种**上下文切换**很耗性能，类似的还有单机进程间调用、远程过程调用等。
2. 很多 DOM API 的读写都涉及**页面布局的“重新计算”**，以确保返回值的准确，涉及样式、结构的还会触发**页面“重新绘制”**，更耗性能。

综上，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 **DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。**

所以，解决此问题的方案本质不在于用不用 jQuery、用不用虚拟 DOM，而是 —— **减少不必要的 DOM API 调用**。虚拟 DOM 只是一种可选的方案，不是每种 Web 前端框架都用它。