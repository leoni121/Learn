[TOC]

## 1. VUE/REACT ##

[react和vue的渲染流程对比 以及 特点对比](<https://www.jianshu.com/p/1960f378b5b4>)

### 1.1 react的特点 ###

1. 声明式设计 −React采用声明范式，可以轻松描述应用。
2. 高效 −React通过对DOM的模拟（虚拟dom），最大限度地减少与DOM的交互。
3. 灵活 −React可以与已知的库或框架很好地配合。
4. JSX − JSX 是 JavaScript 语法的扩展。
5. 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中
6. 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。

### 1.2 vue的特点 ###

MVVM框架、双向数据绑定原理，数据驱动、组件化、轻量、简洁、高效、模块友好

### 1.3 两者相比 ###

**react和vue的相似之处：**

1. 使用虚拟dom

2. 提供了响应式和组件化的视图组件

3. 关注核心库，伴随于此，有配套的路由和负责处理全局状态管理的库

**vue的优势**

1. API设计上简单，语法简单，学习成本低

2. 基于依赖追踪的观察系统，并且异步队列更新

3. 简单的语法及项目搭建 ，更快的渲染速度和更小的体积

4. 渲染性能

   渲染用户界面的时候，dom的操作成本是最高的，那为了尽可能的减少对dom的操作，Vue和React都利用虚拟DOM来实现这一点，但**Vue的Virtual DOM实现的权重要轻得多，因此比React的引入开销更少。**

5. **更新性能**
   在`react中`，当一个组件的状态发生变化时，它将会引起`整个组件的子树都进行重新渲染，从这个组件的根部开始`。那为了**避免子组件不必要的重新渲染，您需要随时使用`shouldComponentUpdate`，**并使用不可变的数据结构。 `在Vue中，组件的依赖关系在它的渲染期间被自动跟踪`，因此系统准确地知道哪些组件实际上需要重新渲染。这就意味着在更新方面,vue也是快于React。

   > Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 

6. 开发中
   在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。这是由于 **React 有大量的检查机制**，这会让它提供许多有用的警告和错误提示信息。vue在实现这些检查时，也更加密切地关注了性能方面。

**react的优势**

1. 更适合大型应用和更好的可测试性
2. Web端和移动端原生APP通吃
3. 更大的生态系统，更多的支持和好用的工具（搭配的router和redux以及其中间件包含了很多重要的思想）
4. 比较适合中大型项目（便于测试和后续调试）
5. 是一种在内存中描述dom数状态的数据结构
6. 支持在服务端渲染

### 1.4 react的渲染流程 ###

1. react中 我们用**jsx来写组件**，它会被**babel转换成纯js**，然后Preact的h函数会将这段js**转换成**DOM树，最后Preact的Virtual DOM算法会将virtual DOM转换成**真实的DOM树**，来构建我们的应用。

2. 真实的Virtual DOM会比下面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。当新一项被加进去这个JavaScript对象时，一个函数会计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在。

![](./img/react-render.png)

### 1.5 vue的渲染流程 ###

1.  Vue的编译器在**编译模板**之后，会把这些模板**编译成一个渲染函数**。而函数被调用的时候就会渲染并且返回一个**虚拟DOM的树**。这个树非常轻量，它的职责就是描述当前界面所应处的状态。

2. 当我们有了这个虚拟的树之后，再**交给一个patch函数**，负责把这些虚拟DOM真正**施加到真实的DOM上**。在这个过程中，Vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。

3. 在渲染过程中，**侦测到的数据来源**之后，之后就可以**精确感知数据源的变动。**到时候就可以根据需要重新进行渲染。

4. 当**重新进行渲染之后**，会生成一个新的树，将**新树与旧树进行对比**，就可以最终得出应施加到真实DOM上的改动。最后再通过patch函数施加改动。

> 要点可以概括为

- 当某个数据属性被用到时，触发 getter，这个属性就会被作为依赖被 watcher 记录下来。
- 整个函数被渲染完的时候，每一个被用到的数据属性都会被记录。
- 相应的数据变动时，例如给它一个新的值，就会触发 setter，通知数据对象对应数据有变化。
- 此时会通知对应的组件，其数据依赖有所改动，需要重新渲染。
- 对应的组件**再次调动渲染函数**，生成 Virtual DOM，实现 DOM 更新。

![](./img/vue-render.webp)

## 2. computed 与 watch ##

[做面试的不倒翁：浅谈 Vue 中 computed 实现原理](https://segmentfault.com/a/1190000016387717)

**computed 和 watch 的差异**

1. `computed` 是计算一个新的属性，并将该属性挂载到 vm（Vue 实例）上，而 `watch` 是监听已经存在且已挂载到 `vm`上的数据，所以用 `watch` 同样可以监听 `computed` 计算属性的变化（其它还有 `data`、`props`）
2. `computed` 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 `computed` 属性，才会计算新的值，而 `watch` 则是当数据发生变化便会调用执行函数
3. 从使用场景上说，`computed` 适用一个数据被多个数据影响，而 `watch` 适用一个数据影响多个数据
4. 计算属性在大多数情况下更合适, 数据变化时执行异步或开销较大的操作时使用`watch` 选项

## 3. [Vue2.0 v-for 中 :key 到底有什么用？](https://www.cnblogs.com/zhumingzhenhao/p/7688336.html) ##

**使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。**

![](./img/vue-diff-key.png)

**key的作用**

* **为了高效的更新虚拟DOM**。
* vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。**见 [知识点.md——4. 用 `key` 管理可复用的元素](./知识点.md)**

## 4. [vue当中如何通过一个点击事件使一个input显示的同时获取焦点](https://segmentfault.com/q/1010000011481239) ##

1、autofocus
2、

```js
directives: {
    focus: {
      inserted(el, { value }) {
        if (value) {
          el.focus();
        }
      },
    },
},
```

```html
<input type="number" ref="input" v-focus="focusStatus" autofocus="autofocus" v-model="goods.price" @blur="changePrice">
```

拓展它的focus
通过点击事件让focusStatus变成true

3、this.$refs.input.focus();

## 5. v-show 和 v-if ##

* `v-if` 是“真正”的条件渲染，因为它会确保在**切换过程中条件块内的事件监听器和子组件适当地被销毁和重建**。当切换v-if模块时，Vue.js 有一个**局部编译/卸载过程**，因为 v-if 之中的模板也可能包括数据绑定或子组件。

* `v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

* `v-show` 不管初始条件是什么，元素总是会被渲染，并且只是简单地**基于 CSS 进行切换。**

* `v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

## 6. solt 和 props ##

**props**

props是用来接收参数的 例如父组件向子组件传参 可以放在props中

**slot**

slot：插槽 slot分发模式主要用于在组件中插入标签或者组件之间的相互嵌套
个人认为如果组件中有需要单独定义的地方 可以使用slot

## 7. vue 生命周期 ##

[如何解释vue的生命周期才能令面试官满意？](<https://juejin.im/post/5ad10800f265da23826e681e>)

![](./img/vue-lifecycle.png)

```js
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

1. **new Init()**
   vue的构造函数中就只调用了一个init方法(我们已经来到了生命周期图的init函数了):init方法哪里来的呢? 我们可以下面调用了:

   ```js
   // 初始化
   initMixin(Vue)
   ```

2. init方法中的events跟lifecyle,字面意思就可以知道是注册**“事件”跟“生命周期”的意思**

   **initlifecyle**
   初始化一些生命周期的变量(未渲染、未销毁等等)

   ```js
     vm._watcher = null
     vm._inactive = null
     vm._directInactive = false
     vm._isMounted = false
     vm._isDestroyed = false
     vm._isBeingDestroyed = false
   ```

   **initEvent**

   ```js
   // 就是我们执行vm.once、vm. once、vm.once、vm.on、vm.$emit方法发送的一些事件,分为注册事件跟触发事件(观察者模式)
   ```

3. **callHook(vm, 'beforeCreate')**
   在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。

4. **initInjections**

   ```js
   initInjections(vm) // resolve injections before data/props
   initState(vm)
   initProvide(vm) // resolve provide after data/props
   ```

   在父类或者超类组件中定义了一些基础数据,子类组件需要拿到这些基础数据,我们就可以用inject, inject中包含了initInjections跟initProvide.
   [知识点.md——14.4 依赖注入](./知识点.md)

5. **initState**的目的就是初始化一些响应式操作,具体有:data属性、props属性、computed属性、watch属性. 

6. **initProvide**

7.  **callHook(vm, 'created')**

8. 判断instance（实例）里面是否含有**“el”option（选项）**，如果没有的话，它会调用vm.$mount(el)这个方法，

9. 判断是否含有“template”这个选项，如果有的话，它会把template解析(template编译的过程)成一个render function

   ```js
   render (h) {
     return h('div', {}, this.text)
   }
   ```

   render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容。

   **render函数是发生在beforeMount和mounted之间的**当执行完render function之后，就会调用mounted这个钩子，

10. mountComponent

    ```js
     // 1.
     callHook(vm, 'beforeMount')
    ```

11. updateComponent

    ```js
    // 1.
    render()
    
    // 2.
    callHook(vm, 'mounted')
    ```

12. lifecycleMixin 
    **_update**
     callHook(vm, 'beforeUpdate')

    **destroy** 

    ```js
    // 1.
    callHook(vm, 'beforeDestroy')
    
    // 2.
    if (vm._watcher) {
    	vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
    	vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
    	vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    
    // 3.
    callHook(vm, 'destroyed')
    ```

13. **额外**
    * 在使用.vue文件开发的过程当中，**我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面**。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。
    * 在这个过程当中，Vue为我们提供了**renderError**方法，这个方法只有在开发的时候它才会被调用，在正式打包上线的过程当中，它是不会被调用的。它主要是帮助我们**调试render里面的一些错误。**

## 8. 组件依赖关系追踪原理 ##

Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。



<http://www.php.cn/js-tutorial-409801.html>