[TOC]

## 1. 函数提升、变量提升 ##

**变量和函数都整体提升后，函数整体在变量的后面**。变量提升之后，但其赋值还是留在原本的位置等js运行到了之后动态赋值，而函数提升之后直接相当于在代码里抽空了。

**“提升”的本质就是为了事先声明变量和函数**，当然函数只有声明式函数才会被提升，字面量函数不会被提升。这种提升就是存在于作用域中，包括全局作用域、函数作用域（闭包形成的作用域也是个函数作用域），总之都是在作用域中声明变量和函数时，会提升到作用域顶部，进行事先声明。

## 2. 作用域 和 **作用域链** ##

> es6 之前
>
> [JS函数作用域及作用域链理解](https://www.cnblogs.com/mrzl/p/4415149.html)

**作用域**

**任何编程语言都有作用域的概念，简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。**

1. 全局作用域
   任何地方都能访问到的对象拥有全局作用域。

2. 局部作用域

   局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以在一些地方会把这种作用域成为函数作用域。

3. ES6的块级作用域

   ES5只有全局作用域和函数作用域，没有块级作用域，

**作用域链**

通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。**保证对执行环境有权访问的所有变量和函数的有序访问**

执行此函数时会创建一个称为“运行期上下文(execution context)”（有人称为运行环境）的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。

（1）ES5 只有全局作用域和函数作用域，没有块级作用域

## 3. 执行环境 和 执行环境栈 ##

### 3.1 执行环境 ###

(或者说运行期上下文)：执行环境（execution context）定义了变量或函数有权访问的其它数据，决定了它们的各自行为

执行环境是 ECMA-262 中用以**区分不同的可执行代码的抽象概念**，每当程序的执行流进入到一个可执行的代码时，就进入到了一个**执行环境**中。

可执行代码的类型可以为分为：

- 全局代码：程序载入后的默认环境，是运行在程序级别的代码。
- 函数代码：当执行流进入一个函数后。
- Eval代码：Eval 内部的代码。

### 3.2 执行环境栈（Execution Stack） ###

执行流依次进入的执行环境在逻辑上形成了一个栈，栈的底部永远是全局环境，栈的顶部则是处于活动状态当前的执行环境(浏览器总是执行处于栈顶的上下文)。当执行流进入一个函数时，函数的环境就会被推入这个环境栈中，当函数执行完毕之后，栈将这个执行环境弹出，然后把控制权返回给之前的执行环境。

## 4. 变量对象、活动对象 ##

**变量对象**

定义了变量或函数有权访问的其他数据。每个执行环境都有一个表示变量的对象，变量对象，这个对象里**储存着在当前环境中所有的变量和函数**。

**活动对象**

**没有执行当前环境之前，变量对象中的属性都不能访问**。但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。所以**活动对象实际就是变量对象在真正执行时的另一种形式**。

## 5. 词法作用域 ##

> 词法作用域和动态作用域：
>
> 1. 词法作用域是在写代码或者说定义时确定的，而**动态作用域是在运行时确定**的。 
> 2. 词法作用域关注函数在何处声明，而动态作用域关注函数从何处**调用**。

**词法作用域是作用域的一种工作模型******，作用域有两种工作模型，在JavaScript中的词法作用域是比较主流的一种，另一种动态作用域（比较少的语言在用）。

所谓的词法作用域就是**在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了**。