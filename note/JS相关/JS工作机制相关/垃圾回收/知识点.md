[TOC]

## 1. 概述 ##

JavaScript 中的内存管理是自动执行的，而且是不可见的。垃圾收集器会按照固定的时间间隔周期性的执行。（JS中最常见的垃圾回收方式是标记清除。）

### 1.1 什么是垃圾 ###

一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

### 1.2 可达性 ###

JavaScript 中内存管理的主要概念是可达性。简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。

## 2. 标记清除（常见） ##

工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

### 2.1 工作流程 ###

1. 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。
3. 再被加上标记的会被视为准备删除的变量。
4. 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

### 2.2 示意图 ###

![js垃圾回收-标记](..\..\img\js垃圾回收-标记.jpg)

### 2.3 优化 ###

- **分代回收**——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
- **增量回收**——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
- **空闲时间收集**——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。

## 3. 引用计数 方式 ##

​    ***工作原理***：跟踪记录每个值被引用的次数。
​    ***工作流程***：

1. 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。
2. 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.
3. 包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.
4. 当引用次数变成0时，说明没办法访问这个值了。
5. 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。