[TOC]
let p = new MyPromise((resolve, reject) => {
  let last = +new Date();
  setTimeout(() => {
    console.log("异步完成");
    resolve((+new Date() - last) / 1000 + "s");
  }, 2000)
})

p.then((time) => {
  console.log("一共花费" + time + "s");
})


执行过程
    （1）创建 MyPromise 实例

    （2）执行传入的函数，并将绑定了this（当前Promise 实例对象）的_resolve, _reject （这两个函数主要用于改变Promise 的状态）

    （3）执行完之后,等待异步完成（setTimeout）

    （4）执行p.then, 即执行Promise 中的方法 then（返回一个新的 Promise实例）

    （5）创建新的MyPromise 实例

    （6）执行创建新的Promise 实例时传入的函数（该函数是then方法中的函数），该函数是个无延迟的函数（暂时这么理解）

    （7）通过上一个Promise的状态判断是否进行相应的函数（fulfilled 和 rejected ），或者添加进入相应的缓冲队列（这里是加入缓冲区）

    （8）等待或者直接（异步完成）执行上一个Promise的_resolve 方法

    （9）判断 _resolve 中传入的是什么（应该是异步执行的结果， 但是也可能是另一个Promise）,不管怎么样都要改变this._value 这个是（3）的异步结束后在resolve 中传入的值 或者 是在（3）中异步结束后传入的Promise 中的异步的值

    （10）循环相应的缓冲队列this._fulfilledQueues 和 this._rejectedQueues（队列中的函数是在then中注册的回调函数）fulfilled 和 rejected ）
        上面（6）中的函数里面有fulfilled 和 rejected 两个状态对应的函数，这两个函数根据then中传入的onFulfilled 和 onRejected 的 类型和 返回值（类型是函数时）做不同的操作
        a.类型不是函数，执行新创建的Promise 中的resolve（这里无异步，所以直接进行resolve）,



