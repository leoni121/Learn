** await命令后面是一个thenable对象（即定义then方法的对象），那么await会将其等同于 Promise 对象

** async function f() {
     await Promise.reject('出错了');
     // 等同 return await Promise.reject('出错了');
   }
   f().then(v => console.log(v)).catch(e => console.log(e))// 出错了


** 不存在继发关系，最好让它们同时触发。

**  任务执行顺序
    1.同步
        // 此时是并发操作不是继发执行 ———— http://www.ruanyifeng.com/blog/2015/05/async.html（六、注意点）
        function dbFuc(db) { //这里不需要 async
          let docs = [{}, {}, {}];
          // 可能得到错误结果
          docs.forEach(async function (doc) {
            await db.post(doc);
          });
        }

        async function dbFuc(db) {
          let docs = [{}, {}, {}];
          let promises = docs.map((doc) => db.post(doc));

          let results = await Promise.all(promises);
          console.log(results);
        }

        // 或者使用下面的写法（同上一种）
        async function dbFuc(db) {
          let docs = [{}, {}, {}];
          let promises = docs.map((doc) => db.post(doc));

          let results = [];
          for (let promise of promises) {
            results.push(await promise);
          }
          console.log(results);
        }


        let [foo, bar] = await Promise.all([getFoo(), getBar()]);


        let fooPromise = getFoo();
        let barPromise = getBar();
        let foo = await fooPromise;
        let bar = await barPromise;

    2.异步
        async function dbFuc(db) {
          let docs = [{}, {}, {}];
          for (let doc of docs) {
            await db.post(doc);
          }
        }

    3.同步， 顺序
        async function logInOrder(urls) {
          // 并发读取远程URL
          const textPromises = urls.map(async url => {
            const response = await fetch(url);
            return response.text();
          });

          // 按次序输出
          for (const textPromise of textPromises) {
            console.log(await textPromise);
          }
        }

** foreach与async/await的关系
    ———— https://blog.csdn.net/lc315yuhuofei/article/details/78601834

    ———— https://www.zhihu.com/question/53466898/answer/259826558
