///1
ƒ () { [native code] }
a.__proto__ === Function.prototype
function（）{}

///2
Function.__proto__.__proto__ === Object.prototype


// Object.__proto__ === Function.__proto__ === Function.prototype;
function（）{}

/// 5
1、从服务器fetch到数据, 保存和取消
2、不想修改原对象


// 7
 (1)transition: background 2s ease,transform 2s ease-in 1s;
 (2)@keyframes animation: changebox 10s ease-in-out   3 alternate paused;
css 渲染线程分为main thread(主线程)和compositor thread(合成器线程)。
(3)requestAnimationFrame 
	【1】requestAnimationFrame会把每一帧中的所有DOM操作集中起来，
	在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率

　　【2】requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量

　　【3】requestAnimationFrame是由浏览器专门为动画提供的API
		在运行时浏览器会自动优化方法的调用
		不是激活状态下的话，动画会自动暂停，有效节省了CPU开销

(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。

        (2)代码的复杂度高于CSS动画

优点：(1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。

        (2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成
    
        (3)CSS3有兼容性问题，而JS大多时候没有兼容性问题


​		
​		
// 
IntersectionObserver
**.observe()

onscorll
scroolTop offsetTop

// 柯里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数

// <meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//www.zhix.net">
<link rel="dns-prefetch" href="//api.share.zhix.net">
<link rel="dns-prefetch" href="//bdimg.share.zhix.net">

// DllReferencePlugin
AddAssetHtmlPlugin
DllPlugin