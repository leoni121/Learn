[TOC]

## 1. 箭头函数 ##

（1）函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。

（2）不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。

（3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。

## 2. 宏任务和微任务，都有哪些 ##

## 宏任务： ##

| #                     | 浏览器 | Node |
| --------------------- | :----: | ---: |
| I/O                   |   ✅    |    ✅ |
| setTimeout            |   ✅    |    ✅ |
| setInterval           |   ✅    |    ✅ |
| setImmediate          |   ❌    |    ✅ |
| requestAnimationFrame |   ✅    |    ❌ |

## 微任务： ##

| #                          | 浏览器 | Node |
| -------------------------- | :----: | ---: |
| process.nextTick           |   ❌    |    ✅ |
| MutationObserver           |   ✅    |    ❌ |
| Promise.then catch finally |   ✅    |    ✅ |

## 3. 关于 new 方法 ##

[js中的new()到底做了些什么？？](https://www.cnblogs.com/faith3/p/6209741.html)

```js
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
```

## 4. [Js将类数组转化为数组](https://www.cnblogs.com/czy960731/p/9320066.html) ##

1. 创建新数组，把类数组的元素添加到新数组中，大家都会我就不写了
2. 通过Array.prototype.slice.call()将类数组对象传入即可。
3. es6中的新方法Array.form()

## 5. 遍历以及for in 方法 ##

1. 使用Object.keys()遍历
   返回一个数组,包括对象自身的(不含继承的、不含prototype上的)所有可枚举属性(不含Symbol属性).
2. 使用Object.getOwnPropertyNames(obj)遍历
   返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).
3. 使用for..in..遍历
   循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).
4. 使用Reflect.ownKeys(obj)遍历
   返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.不会遍历_proto_

## 6. hasOwnProperty() 方法 ##

用来判断某个对象是否含有指定的属性的 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean) 。

## 7. 项目文件如何部署在服务器端 ##

1. [如何将Java Web项目部署到服务器上](https://www.cnblogs.com/jxgapyw/p/6082451.html)

2. [服务器部署NODE项目](<https://www.jianshu.com/p/9a0f356f89ca>)

## 8. let转es6/const  ##

```js
//第一种方法：属性层面,对象可扩展
var CONST = {};
Object.defineProperty(CONST, "A", {
    value: 1,
    enumerable: true
});

//第二种方法：对象层面，对象不可扩展
var CONST = {};
CONST.A = 1;
Object.freeze(CONST);

// let 实现
function outputNum(count){
//块级作用域
  (function(){
    for(var i = 0; i < count; i ++){
      console.log(i)
    }
  })();
  console.log(i)
}
```

## 9.  [1,2,2,3,3,3,4,4,4,5,5,5,5,6,6] 找出数组中只出现一次的数字 ##

```js
function getSingle(arr) {
  let single = arr[0],
    pre = arr[0],
    total = 1;
  for (let i = 1, len = arr.length; i < len; i++) {
    if (arr[i] === pre) {
      total ++;
    } else if (total === 1) {
      single = pre;
      break;
    } else {
      pre = arr[i];
      total = 1;
    }
  }
  if (total === 1) {
    single = arr[arr.length-1];
  }
  return single;
}
```

## 10. 深拷贝 ##

```js
/**
 * @author Nzq
 * @date 2019/3/9
 * @Description: 得到相应的对象， 该方程参考https://www.cnblogs.com/rusr/p/8984604.html
 *  1、从服务器fetch到数据, 保存和取消
 *  2、不想修改原对象
 * @Param:
 */
function getType(obj) {
  let map = {
    '[object Boolean]'  : 'boolean',
    '[object Number]'   : 'number',
    '[object String]'   : 'string',
    '[object Function]' : 'function',
    '[object Array]'    : 'array',
    '[object Date]'     : 'date',
    '[object RegExp]'   : 'regExp',
    '[object Undefined]': 'undefined',
    '[object Null]'     : 'null',
    '[object Object]'   : 'object',
  }
  // return (obj instanceof Element) ? 'element' : map[typeOf(obj)];
  return  map[Object.prototype.toString.call(obj)]
}

/**
 * @author Nzq
 * @date 2019/3/9
 * @Description: 拷贝
 * @Param:
 */
function deepClone(obj) {
  let visitedQueue = [];

  return (
    function _deepClone(obj) {
      let resObj;
      let type = getType(obj);

      if (type === 'object') {
        resObj = {};
      } else if (type === 'array') {
        resObj = [];
      } else {
        return obj
      }

      for(let key in obj){
        let index = visitedQueue.indexOf(obj[key]);
        if (index >= 0) { // 检查是否已经遍历
          resObj[key] = obj[key];
        } else {
          visitedQueue.push(obj[key]);
          resObj[key] = _deepClone(obj[key]);
        }
      }

      return resObj;
    }
  )(obj)
}

/**
 * @author Nzq
 * @date 2019/3/10
 * @Description: 广度优先
 * @Param:
 */
function deepClone1 (nzq) {
  let resObj = {};
  let originQueue = [nzq]; // 用来（广度）遍历循环
  let copyOriginQueue = [resObj]; // 这个和上一个保持同步（不然会copy出错）

  //以下两个队列用来保存复制过程中访问过的对象，以此来避免对象环的问题（对象的某个属性值是对象本身）
  let visitedQueue = []; // 记录已经遍历了的对象

  while (originQueue.length) {
    // _obj 和 _resObj 是同步的，相对应
    let _obj = originQueue.shift();
    let _resObj = copyOriginQueue.shift();

    visitedQueue.push(_obj); // 记录

    for (let key in _obj) {
      let _value = _obj[key];

      if (getType(_value) !== 'object') { // 当前不是Object
        _resObj[key] = _value;
      } else { // 当前是Object

        let index = visitedQueue.indexOf(_value); // 查看是否已经访问过
        if (index >= 0) { // 记录中有

          _resObj[key] = visitedQueue[index];
        } else { // 记录中没有

          // 当前_value 是对象将其放入originQueue 中
          originQueue.push(_value);
          // 为了保持同步
          _resObj[key] = {};
          // 将_value 对应的对象放入copyOriginQueue中
          copyOriginQueue.push(_resObj[key]);
        }
      }
    }
  }

  return resObj
}
```

## 11 .事件循环(nodejs) ##

```js
console.log(1);
setTimeout(() => {console.log(2)}, 0);
Promise.resolve().then(() => {console.log(3)});
PROCESS.NEXTtICK(() => {console.log(4)});
// 1 => 4 => 3 => 2;
```

## 12. 实现一个浏览器 ##

1. GUI 渲染线程
2. JS 引擎线程
3. 事件触发线程
4. 定时触发器线程
5. 异步HTTP 请求线程

## 13. css 优化，解析 ##

[本地——note/前端优化/前端常见可优化处/知识点.md——4. css性能](../../前端优化/前端常见可优化处/知识点.md)

> 1. 解析：
>    - 减少css嵌套，最好不要套三层以上
>    - 不要在ID选择器前面进行嵌套
>    - 减少通配符*或者类似[hidden="true"]这类选择器的使用
>    - 不要在类名前面加上标签名
>    - 不用css表达式
> 2. 大小、公用：
>    - 建立公共样式类
>    - 缩写css
>    - 拆分出公共css文件
>    - cssSprite，合成所有icon图片
> 3. 原有机制
>    - 巧妙运用css的继承机制
>    - 少用css rest

- **减少css嵌套，最好不要套三层以上**，一般情况下块级元素加上类，里面的内联元素不用加，css写的时候块级class套内联tag，这样不仅可以减少css文件大小，还能减少性能浪费。
- **不要在ID选择器前面进行嵌套**，ID本来就是**唯一的而且人家权值那么大**，前方嵌套完全是浪费性能。
- **建立公共样式类**，把长段相同样式提取出来作为公共类使用，比如我们常用的**清除浮动**，**单行超出显示省略号**等等等，当然如果你使用sass，继承会让你更加方便。
- **缩写css**，其中包括缩写maigin，padding，颜色值等等，要是有两个或者两个以上的margin-，写成margin: **有助于文件大小**。
- **减少通配符*或者类似[hidden="true"]这类选择器的使用**，挨个查找所有...这性能能好吗？当然重置样式这些必须的东西是不能少的。
- **不要在类名前面加上标签名**：别使用p.ty_p 来进行定位，这样往往效率更差，类名应该在全局范围除非公用是唯一的，所以这种做法是应该便面的。
- **巧妙运用css的继承机制**，在css中很多属性是可以继承的比如颜色字体等等，父节点定义了，子节点就无需定义。
- **拆分出公共css文件**，对于比较大的项目我们可以将大部分页面的公共结构的样式提取出来放到单独css文件里，这样一次下载后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。
- **不用css表达式**，可能大家接触比较少，但是要记住的是无论我们怎么炫酷，到了最后都是静态的，所以表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的，因为它并不只是计算一次，一些小的事件可能都会增加它为了有效准确而进行计算求值的次数。
- **少用css rest**，可能你会觉得重置样式是规范，但是其实其中有**很多的操作是不必要不友好的**，有需求有兴趣的朋友**可以选择normolize.css**
- cssSprite，**合成所有icon图片**，用宽高加上bacgroud-position的背景图方式显现出我们要的icon图，这是一种十分实用的技巧，极大减少了http请求。

## 14. 前端 工程化，模块化 ##

## 15. 计算机网络模型 ##

[本地——note/计算机基础/计算机网络/网络模型、分层.md](../计算机基础/计算机网络/网络模型、分层.md)