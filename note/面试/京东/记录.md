[TOC]

## 1. node多线程 ##

[worker_threads 模块](<https://juejin.im/post/5c63b5676fb9a049ac79a798>)

## 2. node的全局对象及全局变量有哪些 ##

> JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。
>
> 1. 在浏览器 JavaScript 中，通常 window 是全局对象。
> 2.  Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。**global 最根本的作用是作为全局变量的宿主**

Node.js 中你**不可能在最外层定义变量**，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。

（1）__filename

表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。

（2）__dirname

**__dirname** 表示当前执行脚本所在的目录。

（3）setTimeout(cb, ms)

全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。

（4）clearTimeout(t)

全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 **t** 是通过 setTimeout() 函数创建的定时器。

（5）setInterval(cb, ms)

**setInterval(cb, ms)** 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。

返回一个代表定时器的句柄值。可以使用 **clearInterval(t)** 函数来清除定时器。

setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。

（6）console

console 用于提供控制台标准输出

（7）process

process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。

## 3. Vue生命周期/钩子函数 ##

[本地——note/Vue/问题.md——7. vue 生命周期](../../Vue/问题.md)

## 4.  JSON.parse()大数据阻塞如何处理 ##

1. [Fetch API(window.fetch)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)我注意到[Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)对象拥有一个异步.json方法。

```js
 fetch('/foo.json')  
    .then(function(response) {  
            response.json().then(function(result) {  
                // result is parsed body of foo.json  
            });  
    });
```

2. 分片
3. worker

## 5. 什么是展示型组件和容器组件？(react) ##

1. **容器型组件**
   容器型组件主要表现为组件怎么工作的、数据怎样更新的，不包含任何Virtual DOM 的修改或组合，也不会包含组件的样式。
   如果映射到Redux上，容器型组件就是使用connect的组件，如果映射到Flux上，就是与store绑定的组件。
   通过使用connect从Redux状态树中获取数据。
   通过直接分发任意的action来改变数据。
   通常由React Redux创建容器型组件。
   感知Redux。
2. **展示型组件**
   展示型组件主要表现为组件是怎样渲染的，包含了Virtual DOM的修改或组合，也包含组件的样式，同进不依赖任何形式的store。一般可以写成无状态函数，但实际上由于很多展示型组件里依然存在生命周期方法，所以不一定都是无状态的组件。
   从this.props中获取数据。
   调用从props中传入的action creator来改变数据
   开发者自身创建展示型组件

## 6. 怎么配置样式的按需加载？ ##

1. **样式的按需加载意义不大。**
   css样式的执行不像js，js引擎是单线程，基于事件循环来运行，有一个下载、解析的过程，做按需加载可以避免卡顿。
   而css样式是由浏览器的渲染引擎来做的，会同时构建style数和DOM树，是一次构建完成的，按需加载反而需要不停的进行样式数的构建。
2. **样式模块化开发很重要。**
   css样式利用less。scss等进行模块化开发很重要，可以避免样式的多余和混乱。
3. **scoped**
   加了scoped的组件样式，css选择器后面会有hash值来区分，是不可能和外面的样式混掉的，你可以在控制台看到这个后缀

## 7. css-loader和style-loader的区别 ##

[本地——webpack/loader and plugin.md——css-loader 和style-loader](../../前端工程化/webpack/loader and plugin.md)

- `css-loader`: 加载.css文件，处理 css 文件
- `style-loader`: 把 js 中 import 导入的样式文件代码，打包到 js 文件中，运行 js 文件时，将样式自动插入到`<style>`标签中

## 8. 如何做JS的按需加载？ ##

```js
var scriptList = {};
function load(url, callback) {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = url;
    document.body.appendChild(script);
    scriptList[url] = script;
    if(typeof(callback) !== "undefined"){
        script.onload = function () {
            callback();
        };
    }
}

function *** () {
    var url = "***.js";
    if (scriptList.hasOwnProperty(url)) {
        // ...
    } else {
        load(url, function () {
            // ... 
        });
    }
}
```

## 10. 解释浏览器端JavaScript的事件循环 ##

[本地——/事件循环/事件循环机制.md](../../JS相关/JS工作机制相关/事件循环/事件循环机制.md)

## 11. 介绍事件委托 ##

[本地——前端来自真实大厂的532道面试题/记录：300-359.md——323. 事件冒泡，事件捕获，事件委托的原理，如何实现委托，事件，委托的有点是什么，事件监听](../前端来自真实大厂的532道面试题/记录：300-359.md)

事件委托实现（由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。）
在JavaScript中，**添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。**导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而**导致的DOM访问次数，会延迟整个页面的交互就绪时间。**
**对“事件处理程序过多”问题的解决方案就是事件委托。** **事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。**例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。

## 12. 介绍红黑树 ##

[本地——算法\树\红黑树\知识点.md](../../算法/树/红黑树/知识点.md)