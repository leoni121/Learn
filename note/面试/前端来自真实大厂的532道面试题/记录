359. 盒子模型（见 题510、题388） ———— https://www.cnblogs.com/chengzp/p/cssbox.html
    （MDN） ———— https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model



358. 清除浮动（见 题467）
     （1）父级div定义伪类 .clearfloat:after{display:block;clear:both;content:"";visibility:hidden;height:0}
                          .clearfloat{zoom:1}

     （2）在结尾处添加空div标签clear: .clearfloat{clear:both}

     （3）父级div定义overflow:hidden

     （4）父级div定义overflow:auto

     （5）父级div定义display:table

     （6）额外：父级div也一起浮动，父级定义 height ，撑高

     （7）紧跟在其后的元素 clear



357. 计算器



356. html语义化，好处 （开发和使用） ———— https://www.jianshu.com/p/6bc1fc059b51
    （1）首先，语义化，顾名思义，就是你写的HTML结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。不仅对自己来说，容易阅读，书写。别人看你的代码和结构也容易理解，甚至对一些不是做网页开发的人来说，也容易阅读。那么，我们以后再开发的过程中，一定要注意了，尽量使用官方的有语义的标签，不要再使用一堆无意义的标签去堆你的结构。

    （2）why
        a. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
        b. 用户体验：例如title、alt用于解释名词或解释图片信息的标签尽量填写有含义的词语、label标签的活用；
        c. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
        d. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以有意义的方式来渲染网页；
        e. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。



355. 如何获取当前日期
     Date.prototype.format = function(fmt) {
         var o = {
            "M+" : this.getMonth()+1,                 //月份
            "d+" : this.getDate(),                    //日
            "h+" : this.getHours(),                   //小时
            "m+" : this.getMinutes(),                 //分
            "s+" : this.getSeconds(),                 //秒
            "q+" : Math.floor((this.getMonth()+3)/3), //季度
            "S"  : this.getMilliseconds()             //毫秒
        };
        // 年
        if(/(y+)/.test(fmt)) {
                // 将得到的4位的年的数组装换为对应位数 再替换
                // 字符串才能substr
                fmt = fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length));
        }
         for(var k in o) {
            if(new RegExp("("+ k +")").test(fmt)){
                // 字符串length
                 fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));
             }
         }
        return fmt;
    }



354. float和position的区别 ———— https://www.zhihu.com/question/19588854
    (1) float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。元素添加 float之后，此浮动元素会在其碰到父级元素边框或者另一个浮动元素边框，紧邻其后显示
        浮动元素不会占据块的空间，所以框三就是100%的父容器宽度 500px，但是浮动元素会占据另外的空间，也就是行框空间，通俗的讲就是文本所占的空间。这也是图片float之后，文本会自动环绕图片的原因。浮动元素不占据块级空间，但会影响块级元素之内的文字以及内联元素。
        a 浮动的本质就是用来实现文字环绕
        b 浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示；不会忽略父元素的padding,和自己的margin
        c 浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个（实例中为父元素）任意非浮动元素靠齐；
        d 浮动元素后面的内联元素会向此浮动元素的外边距靠齐。

    (2) 相对于float而言，position:absolute是完全脱离文档流的，它不会占据普通流的空i间，普通流的布局完全不受绝对定位的影响。



353. html5的新特性 ———— https://www.cnblogs.com/vicky1018/p/7705223.html
    （1）语义化标签，语义化标签使得页面的内容结构化
        header, footer, article, nav, detailes, summary, dialog, aside, section

    （2）增强型表单，HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。
        color, date, datetime(选择一个日期（UTC 时间）), datetime-local选择一个日期和时间 (无时区)，email，month, number, range, search, tel, time, url, week

    （3）视屏、音频
        audio, video、source

    （4）Canvas绘图，标签只是图形容器，必须使用脚本来绘制图形

    （5）SVG绘图
        SVG 是一种使用 XML 描述 2D 图形的语言。
        Canvas 通过 JavaScript 来绘制 2D 图形。
        SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
        在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
        Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。

    （6）地理定位

    （7）拖放API

    （8）Web Worker
        if(typeof(w)=="undefined")
          {
            w=new Worker("demo_workers.js");
          }else{
            // //抱歉! Web Worker 不支持
          }
        w.onmessage = function (event) {
            document.getElementById("result").innerHTML=event.data;
          };
        w.terminate();
        postMessage(i);

    （9） Storage
       if(typeof(Storage)!=="undefined")
       {
           // 是的! 支持 localStorage  sessionStorage 对象!
           // 一些代码.....
       } else
       {
         // 抱歉! 不支持 web 存储。
       }
    （10）WebSocket



352. 对前端的了解和个人规划



351. 流式布局 ———— http://www.cnblogs.com/yanayana/p/7066948.html



350. JS基础有几种
    string, number, boolean, null, undefined, symbol



349. Linux命令



348. git命令



347. 给了一个settimeout代码输出的顺序



346. 用过webpack吗，谈一下webpack打包



345. jQuery原理，平时用jQuery都做过什么



344. 深拷贝的实现（参考 JS 文件下的“深拷贝部分实现.js”）
    （0）Object.assign
        {...{}}

    （1） JSON
        限制
            var as = {
            	a: function() {

            	},
            	[Symbol()]:Symbol("nzq"),
            	c: "",
            	d: undefined

            }
            =》
            JSON.stringify(as)
            =》
           "{"c":""}"

    （2）




343. call apply bind的区别
    （1）call apply bind都可以改变函数调用的this指向（运行时的上下文（context））

    （2）apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；

    （3）apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；

    （4）apply 、 call 、bind 三者都可以利用后续参数传参；

    （5）bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。




342. 如何实现移动端布局，适配方案
    （1）
        a. 固定一个某些宽度，使用一个模式，加上少许的媒体查询方案
        b. 使用flexbox解决方案
        c. 使用百分比加媒体查询
        d. 使用rem




341. 项目中是是如何优化页面的  ———— https://www.cnblogs.com/shuangjiang/p/9134024.html



340. 谈谈JS的异步机制
    （1）单线程模型在处理耗时的异步任务是会出现较长时间的线程阻塞，导致后续的任务不能被及时处理。所以在 Javascript 中存在异步的处理方式用于处理这种情况，不过严格来说所谓的异步，本质上还是借助于多线程的宿主实现的，
    （2）在浏览器端：
        a. 定时器, 浏览器的定时器线程执行的定时计数
        b. AJAX请求，委托浏览器线程代为执行耗时任务，这里是借由浏览器的HTTP请求线程发起对服务器的请求，在请求得到响应之后触发请求完成事件，将回调函数推入事件队列等待执行
        c. GUI渲染线程 、 JS引擎线程 、 事件触发线程 、 定时器触发线程 、 http请求线程

    （2）JavaScript 运行机制详解：再谈Event Loop（阮一峰老师）http://www.ruanyifeng.com/blog/2014/10/event-loop.html
        http://javascript.ruanyifeng.com/advanced/single-thread.html




339. 重排重绘 ———— https://www.cnblogs.com/zichi/p/4720000.html
    （1）渲染树中的节点被称为“帧”或“盒",符合CSS模型的定义，理解页面元素为一个具有填充，边距，边框和位置的盒子。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制）页面元素。
    （2）重排，当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。
    （3）重绘， 完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘

    （4）注意：由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。
        让元素脱离动画流， fragment元素的应用, 最小化重排和重绘（防止js 一条一条改变元素）




338. HTTP状态码 ———— https://www.cnblogs.com/jly144000/archive/2017/12/07/7998615.html
     1**	信息，服务器收到请求，需要请求者继续执行操作

     2**	成功，操作被成功接收并处理
         200 OK 服务器成功处理了请求
         204 请求被受理但没有资源可以返回

     3**	重定向，需要进一步的操作以完成请求
         301 永久性重定向，请求的URL已移走
         302 临时重定向
         304 表示未修改，客户的缓存资源是最新的，要客户端使用缓存
        307(临时重定向)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。

     4**	客户端错误，请求包含语法错误或无法完成请求
         400 请求报文语法有误，服务器无法识别
         401(未授权)请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应
         403 禁止，请求被服务器拒绝了
         404 未找到资源
         405	 客户端请求中的方法被禁止

     5**	服务器错误，服务器在处理请求的过程中发生了错误
         500 内部服务器错误，服务器遇到一个错误，使其无法为请求提供服务
         503 服务器正忙，服务器超时



337. 前端安全
    （1）资源枚举
    （2）XSS共计
    （3）DOS攻击
    （4）CSRF攻击
