359. 盒子模型（见 题510、题388） ———— https://www.cnblogs.com/chengzp/p/cssbox.html
    （MDN） ———— https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model



358. 清除浮动（见 题467）
     （1）父级div定义伪类 .clearfloat:after{display:block;clear:both;content:"";visibility:hidden;height:0}
                          .clearfloat{zoom:1}

     （2）在结尾处添加空div标签clear: .clearfloat{clear:both}

     （3）父级div定义overflow:hidden

     （4）父级div定义overflow:auto

     （5）父级div定义display:table

     （6）额外：父级div也一起浮动，父级定义 height ，撑高

     （7）紧跟在其后的元素 clear



357. 计算器



356. html语义化，好处 （开发和使用） ———— https://www.jianshu.com/p/6bc1fc059b51
    （1）首先，语义化，顾名思义，就是你写的HTML结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。不仅对自己来说，容易阅读，书写。别人看你的代码和结构也容易理解，甚至对一些不是做网页开发的人来说，也容易阅读。那么，我们以后再开发的过程中，一定要注意了，尽量使用官方的有语义的标签，不要再使用一堆无意义的标签去堆你的结构。

    （2）why
        a. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
        b. 用户体验：例如title、alt用于解释名词或解释图片信息的标签尽量填写有含义的词语、label标签的活用；
        c. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
        d. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以有意义的方式来渲染网页；
        e. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。



355. 如何获取当前日期
     Date.prototype.format = function(fmt) {
         var o = {
            "M+" : this.getMonth()+1,                 //月份
            "d+" : this.getDate(),                    //日
            "h+" : this.getHours(),                   //小时
            "m+" : this.getMinutes(),                 //分
            "s+" : this.getSeconds(),                 //秒
            "q+" : Math.floor((this.getMonth()+3)/3), //季度
            "S"  : this.getMilliseconds()             //毫秒
        };
        // 年
        if(/(y+)/.test(fmt)) {
                // 将得到的4位的年的数组装换为对应位数 再替换
                // 字符串才能substr
                fmt = fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length));
        }
         for(var k in o) {
            if(new RegExp("("+ k +")").test(fmt)){
                // 字符串length
                 fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));
             }
         }
        return fmt;
    }



354. float和position的区别 ———— https://www.zhihu.com/question/19588854
    (1) float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。元素添加 float之后，此浮动元素会在其碰到父级元素边框或者另一个浮动元素边框，紧邻其后显示
        浮动元素不会占据块的空间，所以框三就是100%的父容器宽度 500px，但是浮动元素会占据另外的空间，也就是行框空间，通俗的讲就是文本所占的空间。这也是图片float之后，文本会自动环绕图片的原因。浮动元素不占据块级空间，但会影响块级元素之内的文字以及内联元素。
        a 浮动的本质就是用来实现文字环绕
        b 浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示；不会忽略父元素的padding,和自己的margin
        c 浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个（实例中为父元素）任意非浮动元素靠齐；
        d 浮动元素后面的内联元素会向此浮动元素的外边距靠齐。

    (2) 相对于float而言，position:absolute是完全脱离文档流的，它不会占据普通流的空i间，普通流的布局完全不受绝对定位的影响。



353. html5的新特性 ———— https://www.cnblogs.com/vicky1018/p/7705223.html
    （1）语义化标签，语义化标签使得页面的内容结构化
        header, footer, article, nav, detailes, summary, dialog, aside, section

    （2）增强型表单，HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。
        color, date, datetime(选择一个日期（UTC 时间）), datetime-local选择一个日期和时间 (无时区)，email，month, number, range, search, tel, time, url, week

    （3）视屏、音频
        audio, video、source

    （4）Canvas绘图，标签只是图形容器，必须使用脚本来绘制图形

    （5）SVG绘图
        SVG 是一种使用 XML 描述 2D 图形的语言。
        Canvas 通过 JavaScript 来绘制 2D 图形。
        SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
        在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
        Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。

    （6）地理定位

    （7）拖放API

    （8）Web Worker
        if(typeof(w)=="undefined")
          {
            w=new Worker("demo_workers.js");
          }else{
            // //抱歉! Web Worker 不支持
          }
        w.onmessage = function (event) {
            document.getElementById("result").innerHTML=event.data;
          };
        w.terminate();
        postMessage(i);

    （9） Storage
       if(typeof(Storage)!=="undefined")
       {
           // 是的! 支持 localStorage  sessionStorage 对象!
           // 一些代码.....
       } else
       {
         // 抱歉! 不支持 web 存储。
       }
    （10）WebSocket



352. 对前端的了解和个人规划



351. 流式布局 ———— http://www.cnblogs.com/yanayana/p/7066948.html



350. JS基础有几种
    string, number, boolean, null, undefined, symbol



349. Linux命令



348. git命令



347. 给了一个settimeout代码输出的顺序



346. 用过webpack吗，谈一下webpack打包



345. jQuery原理，平时用jQuery都做过什么



344. 深拷贝的实现（参考 JS 文件下的“深拷贝部分实现.js”）
    （0）Object.assign
        {...{}}

    （1） JSON
        限制
            var as = {
            	a: function() {

            	},
            	[Symbol()]:Symbol("nzq"),
            	c: "",
            	d: undefined

            }
            =》
            JSON.stringify(as)
            =》
           "{"c":""}"

    （2）




343. call apply bind的区别
    （1）call apply bind都可以改变函数调用的this指向（运行时的上下文（context））

    （2）apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；

    （3）apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；

    （4）apply 、 call 、bind 三者都可以利用后续参数传参；

    （5）bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。




342. 如何实现移动端布局，适配方案
    （1）
        a. 固定一个某些宽度，使用一个模式，加上少许的媒体查询方案
        b. 使用flexbox解决方案
        c. 使用百分比加媒体查询
        d. 使用rem




341. 项目中是是如何优化页面的  ———— https://www.cnblogs.com/shuangjiang/p/9134024.html



340. 谈谈JS的异步机制
    （1）单线程模型在处理耗时的异步任务是会出现较长时间的线程阻塞，导致后续的任务不能被及时处理。所以在 Javascript 中存在异步的处理方式用于处理这种情况，不过严格来说所谓的异步，本质上还是借助于多线程的宿主实现的，
    （2）在浏览器端：
        a. 定时器, 浏览器的定时器线程执行的定时计数
        b. AJAX请求，委托浏览器线程代为执行耗时任务，这里是借由浏览器的HTTP请求线程发起对服务器的请求，在请求得到响应之后触发请求完成事件，将回调函数推入事件队列等待执行
        c. GUI渲染线程 、 JS引擎线程 、 事件触发线程 、 定时器触发线程 、 http请求线程

    （2）JavaScript 运行机制详解：再谈Event Loop（阮一峰老师）http://www.ruanyifeng.com/blog/2014/10/event-loop.html
        http://javascript.ruanyifeng.com/advanced/single-thread.html




339. 重排重绘 ———— https://www.cnblogs.com/zichi/p/4720000.html
    （1）渲染树中的节点被称为“帧”或“盒",符合CSS模型的定义，理解页面元素为一个具有填充，边距，边框和位置的盒子。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制）页面元素。
    （2）重排，当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。
    （3）重绘， 完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘

    （4）注意：由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。
        让元素脱离动画流， fragment元素的应用, 最小化重排和重绘（防止js 一条一条改变元素）




338. HTTP状态码 ———— https://www.cnblogs.com/jly144000/archive/2017/12/07/7998615.html
     1**	信息，服务器收到请求，需要请求者继续执行操作

     2**	成功，操作被成功接收并处理
         200 OK 服务器成功处理了请求
         204 请求被受理但没有资源可以返回

     3**	重定向，需要进一步的操作以完成请求
         301 永久性重定向，请求的URL已移走
         302 临时重定向
         304 表示未修改，客户的缓存资源是最新的，要客户端使用缓存
        307(临时重定向)服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。

     4**	客户端错误，请求包含语法错误或无法完成请求
         400 请求报文语法有误，服务器无法识别
         401(未授权)请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应
         403 禁止，请求被服务器拒绝了
         404 未找到资源
         405	 客户端请求中的方法被禁止

     5**	服务器错误，服务器在处理请求的过程中发生了错误
         500 内部服务器错误，服务器遇到一个错误，使其无法为请求提供服务
         503 服务器正忙，服务器超时



337. 前端安全 ———— http://www.cnblogs.com/vajoy/p/4176908.html
    （1）资源枚举
    （2）XSS攻击
        XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本
       a. 反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。
       b.存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。（留言板）
       c. DOM XSS攻击不同于反射型XSS和存储型XSS，DOM XSS代码不需要服务器端的解析响应的直接参与，而是通过浏览器端的DOM解析。这完全是客户端的事情。 DOM XSS代码的攻击发生的可能在于我们编写JS代码造成的。我们知道eval语句有一个作用是将一段字符串转换为真正的JS语句，因此在JS中使用eval是很危险的事情，容易造成XSS攻击。避免使用eval语句。
       d. XSS危害
          通过document.cookie盗取cookie
          使用js或css破坏页面正常的结构与样式
          流量劫持（通过访问某段具有window.location.href定位到其他页面）
          Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。
          利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。
          利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。
      e. 防御
            对重要的cookie设置httpOnly, 防止客户端通过document.cookie读取cookie。服务端可以设置此字段。
            对用户输入数据的处理
                编码：不能对用户输入的内容都保持原样，对用户输入的数据进行字符实体编码。对于字符实体的概念可以参考文章底部给出的参考链接。
                解码：原样显示内容的时候必须解码，不然显示不到内容了。
                过滤：把输入的一些不合法的东西都过滤掉，从而保证安全性。如移除用户上传的DOM属性，如onerror，移除用户上传的Style节点，iframe, script节点等。

    （3）DOS攻击
        a. 拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。

    （4）CSRF攻击
        a. CSRF（Cross Site Request Forgery），中文是跨站点请求伪造,CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。
            <img style="width:0;" src="http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315"   />
        b. Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。CSRF攻击的一般是由服务端解决。
        c. 我们可以通过提高CSRF的攻击门槛进行适当的防范，做法有：重要的请求应该通过post方式进行（杜绝通过点击链接进行攻击）、服务端生成随机token，保存在页面隐藏域中，在发出请求的时候一并发出，服务端在验证其在session中的token，两者一致后才处理请求，处理请求后必须马上销毁token。（这种做法可以提高攻击难度）、防范XSS攻击（这样能有效防范CSRF）
    （4）钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。

    （5）SQL注入这块不想细聊了，相信很多朋友都听到耳朵长茧，不外乎是提交含有SQL操作语句的信息给后端，后端如果没有做好过滤就执行该语句，攻击者自然可以随意操纵该站点的数据库。
       比如有一个图书馆站点book.com，你点进一本书的详情页面，其url是这样的：
       book.com/book?id=100
       说明这本书在数据库中的键值是100，后端收到url参数后就执行了数据库查询操作：
       select * from booktable where id='100'
       那么如果我们把url更改为
       book.com/book?id=100'or'1'='1
       那么数据库操作执行就变成了：
       select * from booktable where id='100'or'1'='1'
       从而取出了整个booktable 表单的全部数据。

   （6）资源枚举
        遍历你站点所有可访问的目录，然后把一些常见的备胎文件名（比如“sql.bak”、“index-副本.html”）一个个都枚举一下，如果运气好枚举到了就直接下载。



336. 详细说明解决跨域方式 (域名， 端口， 协议)
   (1). js实现 ———— https://www.cnblogs.com/2050/p/3191744.html
       jsonp, script标签
       document.domain设置成自身或更高一级的父域，且主域必须相同，使得s完全控制这个iframe
       postMessage

   (2) nginx

   (3). CORS原理
       CORS是W3c工作草案，它定义了在跨域访问资源时浏览器和服务器之间如何通信。CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。W3C CORS 工作草案
       整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。只需要在服务器端做一些小小的改造即可：
       缺点：CORS要求浏览器(>IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。

   (4). WebSocket



335. vuex的原理 (见 题193)
    http://web.jobbole.com/91187/
    https://505779.kuaizhan.com/20/18/p590841849624be(上)
    http://www.sohu.com/a/290896541_505779（下）
    https://vuex.vuejs.org/zh/guide/actions.html


