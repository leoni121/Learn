[TOC]

## 169. React的生命周期 ##

[参考-博客](<https://www.cnblogs.com/qiaojie/p/6135180.html>)

*1、getDefaultProps()*

设置默认的props，也可以用dufaultProps设置组件的默认属性.

*2、getInitialState()*

在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props

*3、componentWillMount()*

组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。

*4、 render()*

react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。

*5、componentDidMount()*

组件渲染之后调用，只调用一次。

*6、componentWillReceiveProps(nextProps)*

组件初始化时不调用，组件接受新的props时调用。

*7、shouldComponentUpdate(nextProps, nextState)*

react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候

*8、componentWillUpdata(nextProps, nextState)*

组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state

*9、render()*

组件渲染

*10、componentDidUpdate()*

组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。

*11、componentWillUnmount()*

组件将要卸载时调用，一些事件监听和定时器需要在此时清除。

## 168. react的virtual DOM和Diff算法 ##

## 167. 链表找环 ##

## 166. 算法：反转二叉树以及时间复杂度 ##

## 165. 说说bind，apply，call的区别以及bind的实现 ##

### 1. 区别 ###

1. 在调用bind方法改变this指向时，执行的方法不会执行，而调用call方法和apply方法时，在改变this指向的同时，执行的方法也会执行；
2. 使用bind方法和call方法时入参格式为逗号分割的入参，使用apply方法时入参格式为一个数组，入参依次为数组元素，多个入参就在这一数组中依次添加；

### 2. 实现bind ###

```js
Function.prototype.bind = function(ctx) {
	var self = this;
    return function() {
		return self.apply(ctx, arguments);
	}
}
```

>  ***arguments*** 就像  
>
> `Arguments(3) [Array(1), {…}, "12", callee: ƒ, Symbol(Symbol.iterator): ƒ]` 

## 164. 跨域的方法有哪些 ##

参考文件夹 **浏览器 **下的 [记录.md](../../浏览器/浏览器其他知识/记录.md) 

## 163. JS设计模式有哪些 ##

 [Learning  Javascript Design Patterns.pdf](../../设计模式/Learning  Javascript Design Patterns.pdf) 

 [JavaScript 设计模式.html](..\..\设计模式\JavaScript 设计模式.html) 

- JavaScript 设计模式
  - 构造器模式
  - 模块化模式
  - 暴露模块模式
  - 单例模式
  - 观察者模式
  - 中介者模式
  - 原型模式
  - 命令模式
  - 外观模式
  - 工厂模式
  - Mixin 模式
  - 装饰模式
  - 亨元（Flyweight）模式
- JavaScript MV* 模式
  - MVC 模式
  - MVP 模式
  - MVVM 模式
- 最新的模块化 JavaScript 设计模式
  - AMD
  - CommonJS
  - ES Harmony
- JQuery 中的设计模式
  - Composite Pattern
  - 适配器模式
  - 外观模式
  - 观察者模式
  - 迭代器模式
  - 惰性初始模式
  - 代理模式
  - 建造者模式

## 162. Nodejs的线程管理 ##

## 161. cookie，session，localStorage和sessionStorage的区别 ##

![sessionStorage-cookie-localStorage](.\img\sessionStorage-cookie-localStorage.png)

> ***cookie*** 和 ***session*** 参考 [博客](https://blog.csdn.net/weixin_36416680/article/details/80506150)

### 1. session ###

在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。

### 2. Cookie ###

​	2.1 **什么是Cookie**

* Cookie是HTTP协议的规范之一，它是服务器和客户端之间传输的小数据。
* 首先由服务器通过响应头把Cookie传输给客户端，客户端会将Cookie保存起来。
* 当客户端再次请求同一服务器时，客户端会在请求头中添加该服务器保存的Cookie，发送给服务器。
* Cookie就是服务器保存在客户端的数据！
* Cookie就是一个键值对！！！

​      2.2 **Cookie规范**

* Cookie通过请求头和响应头在服务器与客户端之间传输；
* Cookie大小限制在4KB之内；
* 一台服务器在一个客户端最多保存20个Cookie；
* 一个浏览器最多可以保存300个Cookie；
  虽然Cookie规范是如此，但在今天，浏览器厂商的竞争异常激烈，所以多少会超出Cookie规则的限制。但也不会超出过多！
## 160. 你为什么选择前端 ##

## 159. 模块化思想 ##

### 1. 什么是模块? ###

- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。
- 一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。

### 2. 模块化好处 ###

* 避免变量污染，命名冲突
* 提高代码复用率
* 提高维护性
*  依赖关系的管理
* 更好的分离，按需加载

### 3. 演变过程 ###

1. 全局function模式 ：将不同的功能封装成不同的全局函数
   - 编码: 将不同的功能封装成不同的全局函数
   - 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系
2. namespace模式 : 简单对象封装
   - 作用: 减少了全局变量，解决命名冲突
   - 问题: 数据不安全(外部可以直接修改模块内部的数据)

3. IIFE模式：匿名函数自调用(闭包)

   - 作用: 数据是私有的, 外部只能通过暴露的方法操作
   - 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
   - 问题: 如果当前这个模块依赖另一个模块怎么办?

4. IIFE模式增强 : 引入依赖

5. commonJS规范

   > **加载某个模块，其实是加载该模块的module.exports属性**。

   Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**

   (2)特点

   - 所有代码都运行在模块作用域，不会污染全局作用域。
   - 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
   - *模块加载的顺序，按照其在代码中出现的顺序。*

   (3)基本语法

   - 暴露模块：`module.exports = value`或`exports.xxx = value`
   - 引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

   > **require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**

   (4)模块的加载机制

   **CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**。

6. AMD

   Asynchronous Module Definition，中文名是异步模块。它是一个在浏览器端模块化开发的规范，由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。

   requireJS主要解决两个问题：

   * 多个js文件可能有依赖关系，***被依赖的文件需要早于依赖它的文件加载到浏览器***。

   * ***js加载的时候浏览器会停止页面渲染***，加载文件愈多，页面失去响应的时间愈长。

   > 缺点：**首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！**

   **AMD推崇的是依赖前置**，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块。

7. CMD

   CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；CMD推崇依赖就近

8. ES6
   **ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。**ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。

### 4. AMD与CMD区别 ###

[参考-博客](https://www.cnblogs.com/code-klaus/p/9011911.html)

[参考-知乎-玉伯](https://www.zhihu.com/question/20351507/answer/14859415)

***AMD***  在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。

***CMD***  加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。
这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。

***区别概括***

* 对于依赖的模块，AMD 是**提前执行**，CMD 是**延迟执行**。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
* CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。

### 5. ES6 模块与 CommonJS 模块的差异 ###

[参考-博客](http://web.jobbole.com/95559/)

* **CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。

* **CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。

