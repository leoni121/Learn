[TOC]

## 169. React的生命周期 ##

[参考-博客](<https://www.cnblogs.com/qiaojie/p/6135180.html>)

*1、getDefaultProps()*

设置默认的props，也可以用dufaultProps设置组件的默认属性.

*2、getInitialState()*

在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props

*3、componentWillMount()*

组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。

*4、 render()*

react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。

*5、componentDidMount()*

组件渲染之后调用，只调用一次。

*6、componentWillReceiveProps(nextProps)*

组件初始化时不调用，组件接受新的props时调用。

*7、shouldComponentUpdate(nextProps, nextState)*

react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候

*8、componentWillUpdata(nextProps, nextState)*

组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state

*9、render()*

组件渲染

*10、componentDidUpdate()*

组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。

*11、componentWillUnmount()*

组件将要卸载时调用，一些事件监听和定时器需要在此时清除。

## 168. react的virtual DOM和Diff算法 ##

## 167. 链表找环 ##

## 166. 算法：反转二叉树以及时间复杂度 ##

## 165. 说说bind，apply，call的区别以及bind的实现 ##

### 1. 区别 ###

1. 在调用bind方法改变this指向时，执行的方法不会执行，而调用call方法和apply方法时，在改变this指向的同时，执行的方法也会执行；
2. 使用bind方法和call方法时入参格式为逗号分割的入参，使用apply方法时入参格式为一个数组，入参依次为数组元素，多个入参就在这一数组中依次添加；

### 2. 实现bind ###

```js
Function.prototype.bind = function(ctx) {
	var self = this;
    return function() {
		return self.apply(ctx, arguments);
	}
}
```

>  ***arguments*** 就像  
>
> `Arguments(3) [Array(1), {…}, "12", callee: ƒ, Symbol(Symbol.iterator): ƒ]` 

## 164. 跨域的方法有哪些 ##

参考文件夹 **浏览器 **下的 [记录.md](../../浏览器/浏览器其他知识/记录.md) 

## 163. JS设计模式有哪些 ##

 [Learning  Javascript Design Patterns.pdf](../../设计模式/Learning  Javascript Design Patterns.pdf) 

 [JavaScript 设计模式.html](..\..\设计模式\JavaScript 设计模式.html) 

- JavaScript 设计模式
  - 构造器模式
  - 模块化模式
  - 暴露模块模式
  - 单例模式
  - 观察者模式
  - 中介者模式
  - 原型模式
  - 命令模式
  - 外观模式
  - 工厂模式
  - Mixin 模式
  - 装饰模式
  - 亨元（Flyweight）模式
- JavaScript MV* 模式
  - MVC 模式
  - MVP 模式
  - MVVM 模式
- 最新的模块化 JavaScript 设计模式
  - AMD
  - CommonJS
  - ES Harmony
- JQuery 中的设计模式
  - Composite Pattern
  - 适配器模式
  - 外观模式
  - 观察者模式
  - 迭代器模式
  - 惰性初始模式
  - 代理模式
  - 建造者模式

## 162. Nodejs的线程管理 ##

## 161. cookie，session，localStorage和sessionStorage的区别 ##

![sessionStorage-cookie-localStorage](.\img\sessionStorage-cookie-localStorage.png)

> ***cookie*** 和 ***session*** 参考 [博客](https://blog.csdn.net/weixin_36416680/article/details/80506150)

### 1. session ###

在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。

### 2. Cookie ###

​	2.1 **什么是Cookie**

* Cookie是HTTP协议的规范之一，它是服务器和客户端之间传输的小数据。
* 首先由服务器通过响应头把Cookie传输给客户端，客户端会将Cookie保存起来。
* 当客户端再次请求同一服务器时，客户端会在请求头中添加该服务器保存的Cookie，发送给服务器。
* Cookie就是服务器保存在客户端的数据！
* Cookie就是一个键值对！！！

​      2.2 **Cookie规范**

* Cookie通过请求头和响应头在服务器与客户端之间传输；
* Cookie大小限制在4KB之内；
* 一台服务器在一个客户端最多保存20个Cookie；
* 一个浏览器最多可以保存300个Cookie；
  虽然Cookie规范是如此，但在今天，浏览器厂商的竞争异常激烈，所以多少会超出Cookie规则的限制。但也不会超出过多！
## 160. 你为什么选择前端 ##

## 159. 模块化思想  ##

[前端工程化-模块化](..\..\前端工程化\模块化\记录.md)