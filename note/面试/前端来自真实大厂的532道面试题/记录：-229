229. 如何让一个元素消失




228. 清除浮动的方法（见 题467）
  （1）父级div定义伪类 .clearfloat:after{display:block;clear:both;content:"";visibility:hidden;height:0}
                       .clearfloat{zoom:1}

  （2）在结尾处添加空div标签clear: .clearfloat{clear:both}

  （3）父级div定义overflow:hidden

  （4）父级div定义overflow:auto

  （5）父级div定义display:table

  （6）额外：父级div也一起浮动，父级定义 height ，撑高

  （7）紧跟在其后的元素 clear




227. 实现一个两列等高布局，思路（见 文件夹CSS 中的 布局）




226. mongoDB有哪些特点
    MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。




225. B+树了解过吗
    B+ 树 ———— https://blog.csdn.net/qq_26222859/article/details/80631121




224. MySQL里面的索引用过吗




223. 你用过什么数据库




222. 项目用到JAVA，反射来讲




221. 最近在学啥



220. 讲讲JS的语言特性吗 ———— https://blog.csdn.net/lsj960922/article/details/82493986
    JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型
    （1）脚本语言
        JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。

    （2）基于对象
        JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。

    （3）简单
        JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。

    （4）动态性
        JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。在访问一个网页时,鼠标在网页中进行鼠标点击或上下移、窗口移动等操作JavaScript都可直接对这些事件给出相应的响应。

    （5）跨平台性
        JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用,前提上机器上的浏览器支 持JavaScript脚本语言,目前JavaScript已被大多数的浏览器所支持。不同于服务器端脚本语言，例如PHP与ASP，JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时也带来另一个问题：安全性。而随着服务器的强壮，虽然程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖Javascript在客户端进行支持。随着引擎如V8和框架如Node.js的发展，及其事件驱动及异步IO等特性，JavaScript逐渐被用来编写服务器端程序。





** express和koa2的区别
    ———— https://www.jianshu.com/p/e48b9f3fd31f
    （1）koa采用ctx一个参数来调用中间件，而不是express的req, res。

    （2）koa相比express主要就是引入了generator，来避免回调"地狱"问题.

    （3）koa的编程模型是一种 栈 模型 ，而express的设计是串联的

    （4）express 的社区比较早，生态比koa要成熟。

    ———— https://segmentfault.com/a/1190000012960608
    （5）express 线性：m1 => req, res => m2 => req, res => m3 => 响应
        伪代码：
            http.createServer(function (req, res) {
              console.log('m1')
              m1 (req, res) {
                console.log('m2')
                m2 (req, res) {
                  m3 (req, res) {
                    console.log('m3')
                    res.end('hello')
                  }
                }
                console.log('m2 end')
              }
              console.log('m1 end')
            })

            middlewareA before next()
            middlewareB before next()
            middlewareC before next()
            middlewareC after next()
            middlewareB after next()
            middlewareA after next()
            nzq

    （6）koa2
        middlewareA before next()
        middlewareB before next()
        middlewareC before next()
        nzq
        middlewareC after next()
        middlewareB after next()
        middlewareA after next()

    （7）koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。
        koa 是一个比 express 更精简，使用 node 新特性的中间件框架，相比之前 express 就是一个庞大的框架,但是 express 社区强大，该遇到的问题都遇到了，比较好解决。应用丰富，不用自己写。koa 比较灵巧，需要的中间件可以自己写，也不困难，源码易懂。

    （8）启动方式不同，koa采用了new Koa()的方式，而express采用传统的函数形式




218. 你有用到express吗




217. 讲讲JS的闭包 ———— http://caibaojian.com/js-closures-indeep.html
     （1）涉及概念
         a. 每个函数都有一个与之对应的执行环境。
            当函数执行时，会把当前函数的环境押入环境栈中，把当前函数执行完毕，则摧毁这个环境。
            window 全局对象时栈中对外层的(相对于图片来说，就是最下面的)。
         b. 每个执行环境有一个与之对应的变量对象。
            环境中定义的所有变量和函数都保存在这个对象里。
            对于函数，执行前的初始化阶段叫变量对象，执行中就变成了活动对象。
         c. 活动对象实际就是变量对象在真正执行时的另一种形式。
           例子：function fun (a){var n = 12;function toStr(a){return String(a);}}
           在 fun 函数的环境中，有一个变量对象(压入环境栈之前)，三个变量，首先是arguments，变量n 与 函数 toStr ，压入环境栈之后(在执行阶段)，他们都属于fun的活动对象。 活动对象在最开始时，只包含一个变量，即argumens对象。

         d. 数据格式表达作用域链的结构如下。
            [{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。

     （2）闭包是指有权访问另一个函数作用域中的变量的函数；闭包是依据词法作用域产生的必然结果。通过变相引用函数的活动对象导致其不能被回收，然而形成了依然可以用引用访问其作用域链的结果。
     （3）根据调用环境产生的环境栈来形成了一个由变量对象组成的作用域链，当一个环境没有被js正常垃圾回收时，我们依然可以通过引用来访问它原始的作用域链。




216. promise的状态有哪些
    pending（进行中）、fulfilled（已成功）和rejected（已失败）





215. ES6中用过什么




214. CSS选择器有哪些，优先级呢？
    !important > 行内 > id > class > 标签 = 伪类选择器 > * > 继承 > 浏览器




213. CSS中对溢出的处理
    （1）溢出：设置了固定宽度和高度的盒子，其内容的尺寸，超过了盒子本身的尺寸。由于并没有设置 overflow属性，表示使用其默认值 visible，让溢出的内容可见。此时，溢出的内容就会渲染到盒子的外面。

    （2）解决：

    （3）相关：
        a. overflow属性的可选值有 visible | hidden | scroll | auto，除了body 和 textarea 的默认值为auto外，其它元素的默认值为visible。
            可见 - 内容可以在框外呈现。
            隐藏 - 内容被剪切并且不显示滚动条。
            滚动 - 内容被剪辑并显示必要的滚动条。
            自动 - 浏览器决定如何处理内容，它可以因浏览器而异，但通常滚动条会根据需要显示
        b. overflow属性是overflow-x和overflow-y的缩写。overflow-x属性指定处理水平方向的溢出，而overflow-y指定处理垂直方向的溢出。
        c. overflow属性仅适用于块，inline-block和table元素。




212. 如何画一个三角形
   （1） .triangle {
            width: 0;
            height: 0;
            border-width: 50px 50px 0 50px;
            border-color: red transparent;
            border-style: solid;
        }

    （2）气泡框的三角形
        <div class="test_triangle_border">
            <a href="#">三角形</a>
            <div class="popup">
                <span><em></em></span>纯CSS写带边框的三角形
            </div>
        </div>
        利用span做背景颜色和popup边框颜色一样得三角形，em的背景和popup的背景一样，利用span,em的绝对定位的偏移形成“边框”




211. kill指令了解过吗




210. Linux命令用的多吗，怎么样进行进程间通信




209. 设计模式有哪些




208. 线程的哪些资源共享，哪些资源不共享（同一进程间的线程究竟共享哪些资源呢，而又各自独享哪些资源呢？）
    （1）共享的资源有
        a. 堆 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
        b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
        c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
        d. 文件等公用资源 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
    （2）独享的资源有
        a. 栈 栈是独享的
        b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC

    （3）线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。

    （4）进程个性
        a.线程ID
          每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。
       b.寄存器组的值
          由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
       c.线程的堆栈
          堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。
       d.错误返回码
          由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。
       e.线程的信号屏蔽码
          由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。
       f.线程的优先级
          由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的 优先级。




207. 操作系统进程和线程的区别
    （1）线程成为了CPU调度的基本单位，而进程只能作为资源拥有的基本单位

    （2）进程：在操作系统中，能够独立运行，并且作为资源分配的基本单位。它表示运行中的程序。

    （3）进程上下文：一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容。内核在进行进程的切换时，需要保存当前进程的所有状态，即保存当前进程的上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

    （4）线程：是进程中的一个实例，作为系统调度和分派的基本单位。是进程中的一段序列，能够完成进程中的一个功能。

    （5）线程在linux中有时被称为轻量级进程(LightweightProcess，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源（共享整个虚拟地址空间）。

    （6）线程上下文切换当CPU 执行从一个线程（进程）到另一个线程(进程)时，需要先保存当前工作 线程的上下文信息，以便下次回来时重新运行。这些信息包括，

    （7）比较：
        a.多线程之间堆内存共享，而进程相互独立，线程间通信可以直接基于共享内存来实现，比进程的常用的那些多进程通信方式更轻量。
        b.在上下文切换来说，不管是多线程还是都进程都涉及到寄存器、栈的保存，但是线程不需要切换页面映射（虚拟内存空间）、文件描述符等，所以线程的上下文切换也比多进程轻量
        c.多进程比多线程更安全，一个进程基本上不会影响另外一个进程
        d.在实际的开发中，一般不同任务间（可以把一个线程、进程叫做一个任务）需要通信，使用多线程的场景比多进程多。但是多进程有更高的容错性，一个进程的crash不会导致整个系统的崩溃，在任务安全性较高的情况下，采用多进程。

    （8）两者的区别和联系：
       a.同一个进程可以包含多个线程，一个进程中至少包含一个线程，一个线程只能存在于一个进程中。
       b.同一个进程下的所有线程能够共享该进程下的资源
       c.进程结束后，该进程下的所有线程将销毁，而一个线程的结束不会影响同一进程下的其他线程
       d.线程是轻量级的进程，它的创建和销毁所需要的时间比进程小得多
       e.线程在执行时是同步和互斥的，因为他们共享同一个进程下的资源。
       f.在操作系统中，进程是拥有系统资源的独立单元，它可以拥有自己的资源。一般而言，线程不能拥有自己的资源，但是它能够访问其隶属进程的资源




206. tcp建立连接三次握手的区别（见 题278）




205. 如何避免301跳转https ———— https://blog.csdn.net/zhuyiquan/article/details/72654247




204. 301和302的区别 ———— （参考）https://blog.csdn.net/grandPang/article/details/47448395
    （1）官方：
        301 redirect: 301 代表永久性转移(Permanently Moved)
        302 redirect: 302 代表暂时性转移(Temporarily Moved )

    （2）重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。
        a.网站调整（如改变网页目录结构）
        b.网页被移到一个新地址
        c.网页扩展名改变(如应用需要把.php改成.Html或.shtml)
        d.这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

    （3）什么时候进行301或者302跳转呢？
     a.当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。
       b.使用301跳转的场景：
           域名到期不想续费（或者发现了更适合网站的域名），想换个域名。
           在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。
           空间服务器不稳定，换空间的时候。
       c.使用302跳转的场景：
          尽量使用301跳转！

    （3）302 缺点
        网址劫持：
            从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了。




203.get和post的区别 ———— （非常好！）https://www.cnblogs.com/logsharing/p/8448446.html
    （1）GET在浏览器回退时是无害的，而POST会再次提交请求。
        因为Get请求浏览器有缓存,回退时读取的是缓存中的数据. 但是Post没有浏览器缓存会再次发送请求,消耗服务器性能. 我猜是这样哈哈

    （2）GET产生的URL地址可以被Bookmark（数钱），而POST不可以。

    （3）GET请求会被浏览器主动cache，而POST不会，除非手动设置。

    （4）GET请求只能进行url编码，而POST支持多种编码方式。

    （5）GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

    （6）GET请求在URL中传送的参数是有长度限制的，而POST么有。

    （7）对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

    （8）GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

    （9）GET参数通过URL传递，POST放在Request body中。

    （10）GET产生一个TCP数据包；POST产生两个TCP数据包。
        对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
        而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
        也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
        因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
        GET与POST都有自己的语义，不能随便混用。
        据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
        并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。





202. JS的全排列 ———— https://www.jb51.net/article/39291.htm


