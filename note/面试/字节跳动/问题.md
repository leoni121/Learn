[TOC]

## 1. 三次握手 为什么是3次，挥手为什么是4次 ##

[本地——/计算机基础/计算机网络/TCP.md](../../计算机基础/计算机网络/TCP.md)

* 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
* 关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

## 2. 闭包 使用场景 举例，有什么缺点，为什么外面访问不到闭包的变量 ##

### 2.1 优点 ###

* 不会污染全局环境
* 方便进行模块化开发
* 减少形参个数
* 延长了形参的生命周期

### 2.2 缺点 ###

* 坏处就是不恰当使用会造成**内存泄漏**

### 2.3 常用场景 ###

1. 给对象设置私有变量并且利用特权方法去访问私有属性（构造函数创建对象时）

```js
function Fun(){
  var name = 'tom';
  
  this.getName = function (){
    return name;
  }
}

var fun = new Fun(); 
console.log(fun.name);//输出undefined,在外部无法直接访问name
console.log(fun.getName());//可以通过特定方法去访问
```

2. 采用函数引用方式的`setTimeout`调用

   

3. 通过循环给页面上多个dom节点绑定事件

```js
for(var i = 0, len = btns.length; i < len; i++) {
    (function(i) {
        btns[i].onclick = function() {
            alert(i);
        }
    }(i))
}
```

4. 封装变量（立即执行函数，模块化）
   闭包可以将一些不希望暴露在全局的变量封装成“私有变量”。

```js
var mult = (function(){
    var cache = {};
    var calculate = function() {
        var a = 1;
        for(var i = 0, len = arguments.length; i < len; i++) {
            a = a * arguments[i];
        }
        return a;
    }
    
    return function() {
        var args = Array.prototype.join.call(arguments, ',');
        if(args in cache) {
            return cache[args];
        }
        
        return cache[args] = calculate.apply(null, arguments);
    }
}())
```

5. 延续局部变量的寿命

   ```js
   // 这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报，原因是img是report函数中的局部变量，当report函数调用结束后，img对象随即被销毁，而此时可能还没来得及发出http请求，所以此次请求就会丢失。
   var report = function(src) {
       var img = new Image();
       img.src = src;
   }
   report('http://xxx.com/getUserInfo');
   
   // 使用闭包把img对象封闭起来，就可以解决数据丢失的问题
   var report = (function() {
       var imgs = [];
       return function(src) {
           var img = new Image();
           imgs.push(img);
           img.src = src;
       }
   }())
   ```

   