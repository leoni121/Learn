[TOC]
> 部分参考： [优秀前端必知的话题：我们应该做些力所能及的优化](https://segmentfault.com/a/1190000016572057)
>
> ## [送你一张Web性能优化地图](<https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw>) ##
>
> ## [CSS性能优化的8个技巧](<https://juejin.im/post/5b6133a351882519d346853f>) ##

## 1. DNS 预解析

DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验。其中 Chrome 和 Firefox 3.5+ 内置了 DNS Prefetching 技术并对DNS预解析做了相应优化设置。所以 **即使不设置此属性，Chrome 和 Firefox 3.5+ 也能自动在后台进行预解析 。**DNS Prefetch 应该尽量的放在网页的前面，**推荐放在 `<meta charset="UTF-8">` 后面。**具体使用方法如下：

```html
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//www.zhix.net">
<link rel="dns-prefetch" href="//api.share.zhix.net">
<link rel="dns-prefetch" href="//bdimg.share.zhix.net">
```

> 虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询 。如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签：
>
> `<meta http-equiv="x-dns-prefetch-control" content="off">`

## 2. 样式修改相关 ##

1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className：
       // 不好的写法
           var left = 10,
           top = 10;
           el.style.left = left + "px";
           el.style.top  = top  + "px";
       // 推荐写法
           el.className += " theclassname";
           把 DOM 离线后修改。如：
           a> 使用 documentFragment 对象在内存里操作 DOM。
           b> 先把 DOM 给 display:none (有一次 repaint)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。
           c> clone 一个 DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。
2. 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。
3. **尽可能的修改层级比较低的 DOM节点**。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。
4. 为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是会大大减小 reflow 。
5. 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。

## 3. css动画优化 ##

[CSS3 动画卡顿性能优化的完美解决方案](https://www.jb51.net/article/147736.htm)

**概念：**

1. **主线程负责**：运行 JavaScript；计算 HTML 元素的 CSS 样式；页面的布局；将元素绘制到一个或多个位图中；将这些位图交给合成线程。
2. **合成线程负责**：通过 GPU 将位图绘制到屏幕上；通知主线程更新页面中可见或即将变成可见的部分的位图；计算出页面中哪部分是可见的；计算出当你在滚动页面时哪部分是即将变成可见的；当你滚动页面时将相应位置的元素移动到可视区域。

**优化方案：**

- 尽量使用 transform 当成动画熟悉，避免使用 height,width,margin,padding 等；

- 要求较高时，可以开启浏览器开启 GPU 硬件加速。

- 尽可能多的利用硬件能力，如使用3D变形来开启GPU加速

- 尽可能多的使用opacity 和 transform

- 尽可能的让动画元素不在文档流中，以减少重排

- 动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack

  ```css
  -webkit-backface-visibility: hidden;
  -moz-backface-visibility: hidden;
  -ms-backface-visibility: hidden;
  backface-visibility: hidden;
  -webkit-perspective: 1000;
  -moz-perspective: 1000;
  -ms-perspective: 1000;
  perspective: 1000;
  ```

***例子***

> 例如tranform:translate(-20px,0)到transform:translate(0,0)，主**线程只需要进行一次**tranform:translate(-20px,0)到transform:translate(0,0)，然后合成线程去一次将-20px转换到0px，这样的话，**总计1+20计算**。
>
> 在使用height，width，margin，padding作为transition的值时，会造成浏览器主线程的工作量较重，例如从margin-left：-20px渲染到margin-left:0，主线程需要计算样式margin-left:-19px,margin-left:-18px，一直到margin-left:0，而且每一次主线程计算样式后，合成进程都需要绘制到GPU然后再渲染到屏幕上，前后总共进行**20次主线程渲染**，**20次合成线程渲染**，20+20次，**总计40次计算。**

## 4. css性能 ##

* **减少css嵌套，最好不要套三层以上**，一般情况下块级元素加上类，里面的内联元素不用加，css写的时候块级class套内联tag，这样不仅可以减少css文件大小，还能减少性能浪费。
* **不要在ID选择器前面进行嵌套**，ID本来就是**唯一的而且人家权值那么大**，前方嵌套完全是浪费性能。
* **建立公共样式类**，把长段相同样式提取出来作为公共类使用，比如我们常用的**清除浮动**，**单行超出显示省略号**等等等，当然如果你使用sass，继承会让你更加方便。
* **缩写css**，其中包括缩写maigin，padding，颜色值等等，要是有两个或者两个以上的margin-，写成margin: **有助于文件大小**。
* **减少通配符*或者类似[hidden="true"]这类选择器的使用**，挨个查找所有...这性能能好吗？当然重置样式这些必须的东西是不能少的。
* **不要在类名前面加上标签名**：别使用p.ty_p 来进行定位，这样往往效率更差，类名应该在全局范围除非公用是唯一的，所以这种做法是应该便面的。
* **巧妙运用css的继承机制**，在css中很多属性是可以继承的比如颜色字体等等，父节点定义了，子节点就无需定义。
* **拆分出公共css文件**，对于比较大的项目我们可以将大部分页面的公共结构的样式提取出来放到单独css文件里，这样一次下载后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。
* **不用css表达式**，可能大家接触比较少，但是要记住的是无论我们怎么炫酷，到了最后都是静态的，所以表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的，因为它并不只是计算一次，一些小的事件可能都会增加它为了有效准确而进行计算求值的次数。
* **少用css rest**，可能你会觉得重置样式是规范，但是其实其中有**很多的操作是不必要不友好的**，有需求有兴趣的朋友**可以选择normolize.css**
* cssSprite，**合成所有icon图片**，用宽高加上bacgroud-position的背景图方式显现出我们要的icon图，这是一种十分实用的技巧，极大减少了http请求。

## 5. Gzip ##

https://segmentfault.com/a/1190000012571492 （Gzip 和一些服务端的配置）

* gzip能在压缩的基础上再进行压缩50%以上
* **不是每个浏览器都支持gzip的**，如果知道客户端是否支持gzip呢，请求头中有个Accept-Encoding来标识对压缩的支持。客户端http请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到服务端的时候，服务器解析请求头，如果客户端支持gzip压缩，响应时对请求的资源进行压缩并返回给客户端，浏览器按照自己的方式解析，在http响应头，我们可以看到**content-encoding:gzip，**这是指服务端使用了gzip的压缩方式。
* 前面说过了，启用gzip需要客户端和服务端的支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了，现在来说一下几种不同的环境下的服务端如何配置
* node读取的是生成目录中的文件，所以要先用webpack等其他工具进行压缩成gzip

## 6. 图片压缩 ##

## 7. 图片加载 ##

>  滚动加载图片（懒加载）实现原理

## 8. 减少重定向 ##

## 9. Code Splitting ##

能够帮助我们将代码进行拆包，抽取出公共代码。利用这项特性我们可以做更多的优化工作，减少加载时间，例如可以做按需加载。

## 10. Tree Shaking ##

如果你对自己编写的代码很了解，你可以通过在 `package.json` 中添加 `sideEffects` 来启用 `Tree Shaking` ，即摇树优化，帮助我们删掉一些不用的代码。这里不再赘述，详情可以点击[Tree Shaking](https://webpack.js.org/guides/tree-shaking/)。

## 11. Dynamic import ##

在谈到 `Code Spliting` 时，我们不得不想到 `dynamic import` ，在之前版本的 [webpack](https://webpack.js.org/) 中，我们想实现动态加载使用的是 [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure) ，而在新版本中，取而代之的 [import()](https://github.com/tc39/proposal-dynamic-import) ，这是TC39关于使用 [import()](https://github.com/tc39/proposal-dynamic-import)的提案。

## 12. 首屏文件 ##

## 首屏文件 ##

SPA 程序打包出来的html文件一般都是很小的，也就2kb左右，似乎我们还可以利用下这个大小做个优化，有了解[初始拥塞窗口](https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/) 的同学应该知道，通常是14.6KB，也就意味着这我们还能利用剩下的12KB左右的大小去干点什么，这了我**建议内联一些首屏关键的css文件**（可以使用 [criticalCSS](https://github.com/filamentgroup/criticalCSS) ），或者将css初始化文件内联进去，当然你也可以放其他东西，这里只是充分利用下[初始拥塞窗口](https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/) 特性。

## 13. 缓存 ##

这些不变的文件我们就可以好好的利用下，常见(http 1.1)的就是设置 `Etag` ，`Last-Modified` 和 `Cache-Control` 。前面两种属于对比缓存，还是需要和服务器通信一次，只有当服务器返回 `304` ，浏览器才会去读取缓存文件。而 `Cache-Control`属于强制缓存，服务器设定 `max-age` 当过了设定的时间后才会向服务器发起请求。这里打包再配上 `chunk-hash` 几乎可以完美的配置缓存。

当然还可以利用 [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage) 来做缓存，

## 14. 雅虎34条军规 ##

[本地-YaHoo 军规](note/前端性能优化/YaHoo军规/YaHoo军规.md)

## 15. JS 优化 ##

### 1. 数据存取 ###

1. 使用对象字面量代替对象
2. 使用局部变量存储全局变量和对象成员
3. 尽量不用with，eval语句，try-catch的catch子句要谨慎使用
4. 嵌套越深，性能越差，尽量少用。

### 2. DOM编程 ###

> DOM和JavaScript是2个独立的功能，只通过API连接，用JavaScript操作DOM天生就慢，所以应尽量减少用JavaScript操作DOM。

1. 减少访问DOM的次数，把运算尽量留在ECMAScript这一端处

2. innerHTML在绝大多数浏览器中比原生DOM方法要快（最新版的chrome除外），推荐使用。

3. 用element.cloneNode()代替document.createElement()，稍快一些。

4. 缓存HTML集合的length.

   ```js
   //这会是一个死循环，因为取HTML集合的length会重复执行查询的过程。
   var addDivs=document.getElementsByTagName('div');
   for(var i=0,len=addDivs.length;i<len;i++){      document.body.appendChild(document.createElement('div'));
   }
   ```

   

## 111. 开发时 ##

### 1. JS ###

### 2. CSS ###

1. 避免使用滤镜

### 3. 静态资源 ###

1. 优化图像

   - img 元素的 srcset 属性用于浏览器根据宽、高和像素密度来加载相应的图片资源。

     ```html
     <img src="images/gun.png" srcset="images/bg_star.jpg 1200w, images/share.jpg 800w, images/gun.png 320w" sizes="(max-width: 320px) 300w, 1200w"/>
     ```

   - 压缩等

   - css 背景图片 使用 image-set

     ```css
     /* 
     为普通屏幕使用 pic-1.jpg，为高分屏使用 pic-2.jpg，如果更高的分辨率则使用 pic-3.jpg
     */
     body {
          background-image: -webkit-image-set( url(../images/pic-1.jpg) 1x, url(../images/pic-2.jpg) 2x, url(../images/pic-3.jpg) 600dpi);
     	background-image: image-set( url(../images/pic-1.jpg) 1x, url(../images/pic-2.jpg) 2x, url(../images/pic-3.jpg) 600dpi);
      }
     ```

   * 优化 CSS Spirite， 图片合并
   * favicon.ico要小而且可缓存

2. 

## 222. 下载 ##

## 333. 解析 ##