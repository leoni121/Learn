[TOC]

> 文章出于总结和学习目的！
>
> 参考网站：
>
> 1. [嗨，送你一张Web性能优化地图](<https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw>)
> 2. [以用户为中心的性能指标](<https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics>)
> 3. [前端性能量化标准](<https://yq.aliyun.com/articles/598162>)
> 4. [使用 RAIL 模型评估性能](<https://developers.google.com/web/fundamentals/performance/rail>)
>
> 页面加载性能和页面渲染性能

# １、性能度量标准/设定目标

> *并不是所有指标都同样重要，这取决于你的应用。最后根据度量标准设定一个现实的目标。*

## 1.1 、性能度量标准

> FCP < FMP < DCL(DOMContentLoaded Event) < L(Onload Event)

下表是与页面加载性能相关的用户体验。

| 用户体验           | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| 它在发生吗？       | 网页浏览顺利开始了吗？服务端有响应吗？                       |
| 它是否有用？       | 是否已渲染可以与用户互动的足够内容？用户是否能看到足够的内容？ |
| 它是否可用？       | 用户是否可以和页面交互，还是页面仍在忙于加载？               |
| 它是否令人愉快的？ | 交互是否流程和自然，没有卡段或闪烁？                         |



![](./img/指标体现.png)

### 1.1.1 、First paint and first contentful paint (它在发生吗？)

*首次绘制* (FP) 和 *首次内容绘制* (FCP)。 这些指标用于标记导航之后浏览器在屏幕上渲染像素的时间点。这两个指标其实指示了我们通常所说的白屏时间。

白屏时间计算存在争议，如下：

1. 白屏时间 = FCP - FP （个人认为）

2. 白屏时间 = FCP - performance.timing.navigationStart（即用户再按下回车的瞬间到首次内容渲染，见 @寻找海蓝 [文章](<https://juejin.im/post/5d00820b5188255ee806a1c7>)）

3. 没有　performance API 时，使用如下方式

   ```html
   <!--
   [前端优化-如何计算白屏和首屏时间](https://www.cnblogs.com/longm/p/7382163.html)
   
   白屏时间 = firstPaint - pageStartTime;
   -->
   
   <!DOCTYPE html>
   <html lang="en">
   <head>
     <meta charset="UTF-8">
     <title>白屏</title>
     <script type="text/javascript">
       // 不兼容performance.timing 的浏览器，如IE8
       window.pageStartTime = Date.now();
     </script>
     <!-- 页面 CSS 资源 -->
     <link rel="stylesheet" href="common.css">
     <link rel="stylesheet" href="page.css">
     <script type="text/javascript">
       // 白屏时间结束点
       window.firstPaint = Date.now();
     </script>
   </head>
   <body>
     <!-- 页面内容 -->
   </body>
   </html>
   ```

   

这两个指标之间的主要差别在于：

* FP 标记浏览器渲染*任何*在视觉上不同于导航前屏幕内容（就是输入网址enter之前的内容，可通过Performance查看）的时间点。 
* FCP 标记的是浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 `<canvas>` 元素。

在控制台查看 paint 性能：

```js
window.performance.getEntriesByType('paint')
```

在代码中查看 paint 性能：

```js
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    // `entry` is a PerformanceEntry instance.
    console.log(entry.entryType);
    console.log(entry.startTime);
    console.log(entry.duration);
  }
});

// register observer for long task notifications
observer.observe({entryTypes: ["paint"]});
```

### 1.1.2、**First meaningful paint and hero element timing（它是否有用？）** 

FMP(首次有意义绘制) 是回答“它是否有用？”的度量标准。因为很难有一个通用标准来指示所有的页面当前时刻的渲染达是否到了有用的程度，所以当前并没有制定标准。对于开发者，我们可以根据自己的页面来确定那一部分是最重要的（主角元素计时），然后度量这部分渲染出的时间作为FMP。如果页面最重要的部分能迅速加载，用户可能不会注意到其余部分是否加载。

![](./img/perf-metrics-hero-elements.png)

chrome 提供的性能分析工具 Lighthouse 可以测量出页面的 FMP。其使用的算法是：页面绘制布局变化最大的那次绘制（根据 页面高度/屏幕高度 调节权重）

chrome 提供的性能分析工具 Lighthouse 可以测量出页面的 FMP，在查阅了一些资料后，发现 Lighthouse 使用的算法是：页面绘制布局变化最大的那次绘制（根据 页面高度/屏幕高度 调节权重）

```
First meaningful paint = Paint that follows biggest layout change
layout significance = number of layout objects added / max(1, page height / screen height)
```

### 1.1.3、**Time to interactive（它是否可用？）** 

*可交互时间* (TTI) 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点。 应用可能会因为多种原因而无法响应用户输入：

- 页面组件运行所需的 JavaScript 尚未加载。
- 耗时较长的任务阻塞主线程（如上一节所述）。

TTI 指标可识别页面初始 JavaScript 已加载且主线程处于空闲状态（没有耗时较长的任务）的时间点。

### 1.1.4、Long tasks（它是否令人愉快的？）

当用户有输入时，触发相应的事件，浏览器将相应的任务放入事件循环队列中。js 单线程逐个处理事件循环队列中的任务。 
如果有一个任务需要消耗特别长的时间，那么队列中的其他任务将被阻塞，那么 ui 渲染就被阻塞了。任务耗时较长表现为滞后或卡顿，而这也是目前网页不良体验的主要根源。

![](/home/nzq/Desktop/Learn/note/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/img/perf-metrics-long-tasks.png)

[Long Tasks API](https://w3c.github.io/longtasks/) 可以将任何耗时超过 50 毫秒的任务标示为可能存在问题，并向应用开发者显示这些任务。 选择 50 毫秒的时间是为了让应用满足在 100 毫秒内响应用户输入的 [RAIL 指导原则](https://developers.google.com/web/fundamentals/performance/rail)。

### 1.1.5、其他

1. 输入响应（Input responsiveness）
   界面响应用户输入所需的时间

2. 感知速度指数（Perceptual Speed Index，简称PSI）

   测量页面在加载过程中视觉上的变化速度，分数越低越好

3. 自定义指标

   由业务需求和用户体验来决定。



## 1.2、性能测试

> 性能测量代码最重要的规则是不应降低性能。

### 1.2.1、本地开发时性能的测量

[Lighthouse](https://yq.aliyun.com/go/articleRenderRedirect?url=https://developers.google.com/web/tools/lighthouse/) 和 [Web Page Test](https://yq.aliyun.com/go/articleRenderRedirect?url=https://www.webpagetest.org/) 为我们本地开发提供了非常好的性能测试工具，而且对于我们前面提到的各项测量标准都有较好的支持。但是，这些工具不能在用户的机器上运行，所以它们不能反映用户真实的用户体验。

### 1.2.2、实际用户的设备上测量

> 随着新 API 的推出，我们可以再用户设备上测量这些性能而不需要付出用可能使性能变差的 hack 的方式。 新的 API 是 [`PerformanceObserver`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver)、[`PerformanceEntry`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry) 和 [`DOMHighResTimeStamp`](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp)

1. 检测耗时较长任务的hack手段

   ```js
   (function detectLongFrame() {
     var lastFrameTime = Date.now();
     requestAnimationFrame(function() {
       var currentFrameTime = Date.now();
   
       if (currentFrameTime - lastFrameTime > 50) {
         // Report long frame here...
       }
   
       detectLongFrame(currentFrameTime);
     });
   }());
   ```

   此代码以无限循环的 `requestAnimationFrame` 开头，并记录每次迭代所花费的时间。 如果当前时间距离前次时间超过 50 毫秒，则会认为原因在于存在耗时较长的任务。 虽然大部分情况下此代码都行得通，但其也有不少缺点：

   - 此代码会给每个帧增加开销。
   - 此代码会阻止空闲块。
   - 此代码会严重消耗电池续航时间。

2. FP 和 FCP

   [如上所诉](#1.1.1 、First paint and first contentful paint (它在发生吗？))

3. 用关键元素测量 FMP

   标准中并未定义 FMP，我们需要根据页面的实际情况来定 FMP。一个较好的方式是测量页面关键元素渲染的时间。参考文章 [User Timing and Custom Metrics](https://yq.aliyun.com/go/articleRenderRedirect?url=https://speedcurve.com/blog/user-timing-and-custom-metrics/)。

   测量 css 加载完成时间：

   ```html
   <link rel="stylesheet" href="/sheet1.css">
   <link rel="stylesheet" href="/sheet4.css">
   <script>
   	performance.mark("stylesheets done blocking");
   </script>
   ```

   测量关键图片加载完成时间：

   ```html
   <img src="hero.jpg" onload="performance.clearMarks('img displayed'); performance.mark('img displayed');">
   <script>
     performance.clearMarks("img displayed");
     performance.mark("img displayed");
   </script>
   ```

   测量文字类元素加载完成时间：

   ```html
   <p>This is the call to action text element.</p>
   <script>
     performance.mark("text displayed");
   </script>
   ```

   计算加载时间：

   ```js
   function measurePerf() {
     var perfEntries = performance.getEntriesByType("mark");
     for (var i = 0; i < perfEntries.length; i++) {
       console.log("Name: " + perfEntries[i].name +
         " Entry Type: " + perfEntries[i].entryType +
         " Start Time: " + perfEntries[i].startTime +
         " Duration: "   + perfEntries[i].duration  + "\n");
     }
   }
   ```

4. 测量 TTI

   采用谷歌提供的 [tti-polyfill](https://yq.aliyun.com/go/articleRenderRedirect?url=https://github.com/GoogleChromeLabs/tti-polyfill)。

   ```js
   import ttiPolyfill from './path/to/tti-polyfill.js';
   
   ttiPolyfill.getFirstConsistentlyInteractive().then((tti) => {
     ga('send', 'event', {
       eventCategory: 'Performance Metrics',
       eventAction: 'TTI',
       eventValue: tti,
       nonInteraction: true,
     });
   });
   ```

   [TTI 标准定义文档](https://yq.aliyun.com/go/articleRenderRedirect?url=https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/preview#)

5. 测量 Long Tasks

   ```js
   const observer = new PerformanceObserver((list) => {
     for (const entry of list.getEntries()) {
       ga('send', 'event', {
         eventCategory: 'Performance Metrics',
         eventAction: 'longtask',
         eventValue: Math.round(entry.startTime + entry.duration),
         eventLabel: JSON.stringify(entry.attribution),
       });
     }
   });
   
   observer.observe({entryTypes: ['longtask']});
   ```

6. 跟踪输入延迟

   阻塞主线程的耗时较长任务可能会导致事件侦听器无法及时执行。 [RAIL 性能模型](https://developers.google.com/web/fundamentals/performance/rail)指出，为提供流畅的界面体验，界面应在用户执行输入后的 100 毫秒内作出响应，若非如此，请务必探查原因。

   若要在代码中检测输入延迟，您可将事件时间戳与当前时间作比较，如果两者相差超过 100 毫秒，您可以并应该进行报告。

   ```js
   const subscribeBtn = document.querySelector('#subscribe');
   
   subscribeBtn.addEventListener('click', (event) => {
     // Event listener logic goes here...
   
     const lag = performance.now() - event.timeStamp;
     if (lag > 100) {
       ga('send', 'event', {
         eventCategory:'Performance Metric'
         eventAction: 'input-latency',
         eventLabel: '#subscribe:click',
         eventValue:Math.round(lag),
         nonInteraction: true,
       });
     }
   });
   ```

7. 资源下载时长

   ```
   observer.observe({entryTypes: ['resource']});
   ```

   

## 1.3、设定目标

> [使用 RAIL 模型评估性能](<https://developers.google.com/web/fundamentals/performance/rail>)

- 响应：在 100 毫秒以内响应、*Long tasks*不能超过了 50ms；
- 动画：在 10 毫秒内生成一帧
- 空闲：最大程度增加空闲时间
- 速度指标（Speed Index）小于1250ms；
- 3G网络环境下可交互时间小于5s；
- 重要文件的大小预算小于170kb；

用户如何评价性能延迟：

| 延迟与用户反应 |                                                              |
| :------------- | ------------------------------------------------------------ |
| 0 - 16 ms      | 人们特别擅长跟踪运动，如果动画不流畅，他们就会对运动心生反感。 用户可以感知每秒渲染 60 帧的平滑动画转场。也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），留给应用大约 10 毫秒的时间来生成一帧。 |
| 0 - 100 ms     | 在此时间窗口内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。 |
| 100 - 300 ms   | 用户会遇到轻微可觉察的延迟。                                 |
| 300 - 1000 ms  | 在此窗口内，延迟感觉像是任务自然和持续发展的一部分。对于网络上的大多数用户，加载页面或更改视图代表着一个任务。 |
| 1000+ ms       | 超过 1 秒，用户的注意力将离开他们正在执行的任务。            |
| 10,000+ ms     | 用户感到失望，可能会放弃任务；之后他们或许不会再回来。       |

# ２、编码优化

# ３、静态资源优化

# ４、交付优化

# ５、构建优化

# ６、性能监控