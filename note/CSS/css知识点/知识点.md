[TOC]

## 1. css 参考手册 及 命名规范 ##

[css 参考手册 ](https://www.css88.com/book/css/)

[HTML/CSS开发规范指南](https://www.cnblogs.com/xiangru0921/p/6609917.html)

[DIV+CSS规范命名大全集合](http://www.divcss5.com/jiqiao/j4.shtml)

## 2. 元素选择器优先级 ##

**!important > 行内样式 > ID选择器 > 类选择器 > 元素 = 伪类选择器 > 通配符 > 继承 > 浏览器默认属性**



## 3. @import ##

1.html中
```html
<style>
    @import "";
    @import url("");
    @import url();
</style>
```

2.css中

```css
@import "";
@import url("");
@import url();
```

3.避免css@import
在外部样式表中使用css@import会在加载网页时增加额外的延迟。 css@import允许样式表导入其他样式表。当从外部样式表中使用css@import时，浏览器无法并行下载样式表，这会给整个页面加载增加额外的往返时间。例如，first.css包含以下内容：

```css
@import url（“second.css”）
/* 
    1. 浏览器必须先下载、分析和执行first.css
    2. 然后才能发现它需要下载second.css。
  	
    建议使用<link>标记而不是css@import。这允许浏览器并行下载样式表，从而加快页面加载时间 
*/
```

## 4. @supports 检测是否支持某CSS特性 ##

[参考-官网](https://www.css88.com/book/css/rules/@supports.htm)

## 5. @page ##

   设置页面容器的版式，方向，边空等

## 6. @charset ##

​    字符编码。如：@charset "utf-8";
[参考-官网](https://www.css88.com/book/css/)

## 7. url中的引号问题(@import url(''), @import url(), background-image.....) ##

1. 安全 => 不加的话容易被xss攻击， ""意味着是字符串,但是不加引号的话,传过来的万一是' );url("http://www.xss.xss") '就有可能把cookie什么的可能泄露出去

2. 低系列 IE 不兼容带有引号的写法（网友一个说法是：不加引号且路径里面有空格，老IE认不出）

3. 最好加上，html标签的属性也同理。

4. 如无必要，省略 url 中的引号（出自《CSS 创作指南（Beta）》）；

5. 不写引号完全合法，通常在 CSS 压缩工具中也会去掉 url() 函数中的引号。

6. 不加引号会有一些 edge cases（特殊的 escape 规则等），增加了认知负担，加了引号之后就是常见的字符串规则了；

7. 根据标准原文，不带引号的写法是 “legacy syntax”，虽然出于兼容性考虑肯定不会去掉，但肯定不算是推荐写法；

8. url() 实质上是一个 CSS 函数，它可以接受第二个参数 <url-modifier>，如果用不带引号的写法的话是没办法传第二个参数进去的；

## 8. 滚动条样式 ##

[参考](https://blog.csdn.net/zh_rey/article/details/72473284)

## 9. 边距重叠 ##

[参考](https://www.cnblogs.com/chengzp/p/cssbox.html)

问题：父元素没有设置margin-top，而子元素设置了margin-top：20px;可以看出，父元素也一起有了边距。解决：***BFC***（块级格式化上下文）

## 10. 模态框 ##

```css
 top: 0;
 bottom: 0;
 left: 0;
 right: 0;
```

## 11. 垂直居中（MDN） ##

[本地-垂直居中.html](../布局/垂直居中.html)

## 12. normalize 和 reset ##

[normalize.css](https://github.com/necolas/normalize.css)
[什么是css rest](https://cssreset.com/what-is-a-css-reset)

[***区别***](https://www.cnblogs.com/webpush/p/4974063.html)

使用CSS重置，CSS作者可以强制每个浏览器将其所有样式重置为null，从而尽可能避免跨浏览器的差异。



## 13. Float ##

首先，在W3C标准解析中，float 会使元素脱离文档流，并且浮动元素会生成一个块级框，而不论它是块级或者行内元素。对于这个块级框我是这样理解的：它把这个元素变成了一个（类似）行内块级元素，也就是*`inline-block`*，当你把题中
 `float: left;` 替换为 `display: inline-block;`你会发现，会有一样的结果，为什么说类似呢，因为inline-block 元素之间会默认产生空白符，而float 之间却没有
既然和inline-block 类似，那么当然可以设置宽高了，虽然float 使元素脱离文档流，但是并不影响div 仍然是它的父元素。*因此.height: 100%;也就是继承了父元素的高度，200px，而width: auto;其实是坑人的，因为元素的默认width 就是auto，而inline-block 元素的宽是内容宽度*
这个时候我们看子元素<i>,它设置了position: absolute;同样脱离的文档流，它并不会影响父元素，所以span 的width:0px;



## 14. 盒模型（MDN） ##

[参考-官网](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model)

## 15. 文字平滑 ##

```css
body {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
```

## 16. CSS 选择器解析顺序 ##

[探究 CSS 解析原理 ](https://www.sohu.com/a/205453008_115128)

> 因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。

1. HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。

   > 一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。

2. 在**遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。**

   > 选择器的「解析」实际是在这里执行的

3. 开始过滤出跟目标节点最符合的集合出来，再在这个集合进行搜索(***从右到左解析***)，大大降低了搜索空间。

   * 首先就查找到 的元素；
   * 紧接着我们判断这些节点中的前兄弟节点是否符合 P 这个规则，这样就又减少了集合的元素，只有符合当前的子规则才会匹配再上一条子规则。
   * 试想一下，如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。

## 17. CSS 固定表格宽度 ##

[css 固定HTML表格的宽度](https://www.cnblogs.com/sese/p/6118030.html)

```css
table{
    table-layout: fixed;
    word-break: break-all; 
    word-wrap: break-word;/* 表格固定布局 */
}
```

其中***table-layout:fixed*** 表示：
列宽由表格宽度和列宽度设定。在固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关。

其中***word-break:break-all*** 表示：
word-break 属性规定自动换行的处理方法。break-all允许在单词内换行。

其中***word-wrap: break-word*** 表示：
word-wrap 属性允许长单词或 URL 地址换行到下一行。break-word就表示在长单词或 URL 地址内部进行换行。

其实table-layout, word-break, word-wrap这三个属性都是关于固定宽度显示控制的。

> 对一般的浏览器来说，只需要其中一个就可以完成控制了，但是，一般我们还是会把三个属性都加上，这样以保证对所有的浏览器都兼容。

## 18. 重排、重绘 ##

**重绘（repaint或redraw）**：指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的**新属性**重新绘制，使元素呈现**新的外观**。

> **触发重绘的条件**：改变元素外观属性。如：color，background-color等。
>
> **注意**：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。	

**重排（重构/回流/reflow）**：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(**reflow**)。每个页面至少需要一次回流，就是在页面第一次加载的时候。

**重绘和重排的关系**：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。

## 19. Flex ##

[display:box；display:flex；弹性盒模型](https://www.cnblogs.com/leshao/p/5209694.html)

**(1) 老版本的写法**

> 弹性伸缩盒的原理就是给父元素声明一个display:box伸缩盒属性后，就代表是把整个盒子里的块元素都变成了内联元素，然后这个父元素里面的子元素就可以自由分配空间了，而不会每个块元素各占一行，而是协商共同排在一行上面。可以这么理解。

```css
display: -webkit-box;
display: -moz-box;
display: -ms-flexbox;
display: -o-box;
display: box;
```

**(2) 新版本**

display:flex;将容器盒模型作为块级弹性伸缩盒显示(新版本)
display:inline-flex;将容器盒模型作为内联级弹性伸缩盒显示(新版本)

> 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。

（1）容器的属性
    a. flex-direction属性决定主轴的方向（即项目的排列方向）。
        row（默认值）：主轴为水平方向，起点在左端。
        row-reverse：主轴为水平方向，起点在右端。
        column：主轴为垂直方向，起点在上沿。
        column-reverse：主轴为垂直方向，起点在下沿。
    b. flex-wrap属性定义，如果一条轴线排不下，如何换行
        nowrap（默认）：不换行。
        wrap：换行，第一行在上方。
        wrap-reverse：换行，第一行在下方。
    c. flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
        flex-flow: <flex-direction> || <flex-wrap>;
    d. justify-content属性定义了项目在主轴上的对齐方式。
        flex-start（默认值）：左对齐
        flex-end：右对齐
        center： 居中
        space-between：两端对齐，项目之间的间隔都相等。
        space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
    e. align-items属性定义项目在交叉轴上如何对齐。
        flex-start：交叉轴的起点对齐。
        flex-end：交叉轴的终点对齐。
        center：交叉轴的中点对齐。
        baseline: 项目的第一行文字的基线对齐。
        stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
    d. align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
        flex-start：与交叉轴的起点对齐。
        flex-end：与交叉轴的终点对齐。
        center：与交叉轴的中点对齐。
        space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
        space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
        stretch（默认值）：轴线占满整个交叉轴。

（2）项目的属性
    a. order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
    b. flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。,flex-grow: <number>; /* default 0 */ 有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
    c. flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。
    d. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch

## 20. BFC, Block Formatting Context 直译为“块级格式化上下文” ##

[深入理解CSS盒模型](https://www.cnblogs.com/chengzp/p/cssbox.html)

BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
（1）**创建**

- float属性不为none（脱离文档流）
- position为absolute或fixed
- display为inline-block,table-cell,table-caption,flex,inine-flex
- overflow不为visible
- 根元素

（2）**原理**

- 内部的box会在垂直方向，一个接一个的放置
- 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）
- **box垂直方向的距离由margin决定**，属于同一个bfc的两个相邻box的margin会发生重叠
- **bfc的区域不会与浮动区域的box重叠**
- bfc是一个页面上的**独立的容器**，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的
- **计算bfc高度的时候，浮动元素也会参与计算**

（3）应用

> 清除内部浮动  防止垂直margin重叠  自适应两栏布局

```css
/* 两栏 */
div {
    height: 100px;
    width:180px;
}
.left{
    background:pink;
    float: left;
}
.center{
    background:lightyellow;
    overflow:hidden;
    width: auto; /* auto */
}
.right{
    background: lightblue;
    float:right; /* float:left =》 最右边自适应 */
}

/* <div class="left"></div>
<div class="right"></div>
<div class="center"></div> */
```

## 21. media ##

```css
@media 媒体类型and （媒体特性）{你的样式}
@media screen and (min-width:600px) and (max-width:900px){
    body {background-color:#f5f5f5;}
}
@media only screen and (orientation: landscape) {
    body {
        background-color: lightblue;
    }
}
```

##  ##