[TOC]
> [官网](<http://www.expressjs.com.cn/>)

## 1. Routing ##

（1）、 the routing methods can have more than one callback function as arguments. With multiple callback functions, it is important to provide `next` as an argument to the callback function and then call `next()` within the body of the function to hand off control to the next callback.

（2）、In Express 4.x, [the `*` character in regular expressions is not interpreted in the usual way](https://github.com/expressjs/express/issues/2495). As a workaround, use `{0,}` instead of `*`. This will likely be fixed in Express 5.



## 2. Route handlers ##

Route handlers can be in the form of a function, an array of functions, or combinations of both

## 3. Response methods ##

The methods on the response object (`res`) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be **left hanging.**

| Method                                                       | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [res.download()](http://www.expressjs.com.cn/en/4x/api.html#res.download) | Prompt a file to be downloaded.                              |
| [res.end()](http://www.expressjs.com.cn/en/4x/api.html#res.end) | End the response process.                                    |
| [res.json()](http://www.expressjs.com.cn/en/4x/api.html#res.json) | Send a JSON response.                                        |
| [res.jsonp()](http://www.expressjs.com.cn/en/4x/api.html#res.jsonp) | Send a JSON response with JSONP support.                     |
| [res.redirect()](http://www.expressjs.com.cn/en/4x/api.html#res.redirect) | Redirect a request.                                          |
| [res.render()](http://www.expressjs.com.cn/en/4x/api.html#res.render) | Render a view template.                                      |
| [res.send()](http://www.expressjs.com.cn/en/4x/api.html#res.send) | Send a response of various types.                            |
| [res.sendFile()](http://www.expressjs.com.cn/en/4x/api.html#res.sendFile) | Send a file as an octet(八位字节流) stream.                  |
| [res.sendStatus()](http://www.expressjs.com.cn/en/4x/api.html#res.sendStatus) | Set the response status code and send its string representation as the response body. |

## 4. app.route() ##

You can create chainable route handlers for a route path by using `app.route()`. Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: [Router() documentation](http://www.expressjs.com.cn/en/4x/api.html#router).

Here is an example of chained route handlers that are defined by using `app.route()`.

```javascript
app.route('/book')
  .get(function (req, res) {
    res.send('Get a random book')
  })
  .post(function (req, res) {
    res.send('Add a book')
  })
  .put(function (req, res) {
    res.send('Update the book')
  })
```

## 5. express.Router ##

Use the `express.Router` class to create modular, mountable route handlers. A `Router` instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.

## 6. Writing middleware for use in Express apps ##

[Writing middleware](http://www.expressjs.com.cn/guide/writing-middleware.html)

If the current middleware function does not end the request-response cycle, it must call `next()` to pass control to the next middleware function. Otherwise, the request will be left hanging.

**Configurable middleware**

```js
module.exports = function(options) {
  return function(req, res, next) {
    // Implement the middleware function based on the options object
    next()
  }
}
// The middleware can now be used as shown below.

var mw = require('./my-middleware.js')

app.use(mw({ option1: '1', option2: '2' }))
```

## 8. Using middleware ##

*Middleware* functions are functions that have access to the [request object](http://www.expressjs.com.cn/en/4x/api.html#req) (`req`), the [response object](http://www.expressjs.com.cn/en/4x/api.html#res) (`res`), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named `next`.

An Express application can use the following types of middleware:

- [Application-level middleware](http://www.expressjs.com.cn/guide/using-middleware.html#middleware.application)
- [Router-level middleware](http://www.expressjs.com.cn/guide/using-middleware.html#middleware.router)
- [Error-handling middleware](http://www.expressjs.com.cn/guide/using-middleware.html#middleware.error-handling)
- [Built-in middleware](http://www.expressjs.com.cn/guide/using-middleware.html#middleware.built-in)
- [Third-party middleware](http://www.expressjs.com.cn/guide/using-middleware.html#middleware.third-party)

You can load application-level and router-level middleware with an **optional mount path.** You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.

### **8.1 Application-level middleware** ###

Bind application-level middleware to an instance of the [app object](http://www.expressjs.com.cn/en/4x/api.html#app) by using the `app.use()` and `app.METHOD()` functions, where `METHOD` is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.

a middleware function with no mount path. The function is executed every time the app receives a request.

```js
app.use(func);
app.use(path, func);
app.METHODS(path, func);
```

### **8.2 Router-level middleware** ###

Router-level middleware works in the same way as application-level middleware, except it is **bound to an instance of `express.Router()`**.

**Load router-level middleware by using the `router.use()` and `router.METHOD()` functions.**

```js
// mount the router on the app
app.use('/', router)
```

### **8.3 Error-handling middleware** ###

> Error-handling middleware **always takes *four* arguments**. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the `next` object, you must specify it to maintain the signature. Otherwise, the `next` object will be interpreted as regular middleware and will fail to handle errors.

```js
app.use(function (err, req, res, next) {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
```

For details about error-handling middleware, see: [Error handling](http://www.expressjs.com.cn/en/guide/error-handling.html).

### **8.4 Built-in（内置） middleware** ###

Starting with version 4.x, Express no longer depends on [Connect](https://github.com/senchalabs/connect). The middleware functions that were previously included with Express are now in separate modules; see **[the list of middleware functions](https://github.com/senchalabs/connect#middleware).**

Express has the following built-in middleware functions:

- [express.static](http://www.expressjs.com.cn/en/4x/api.html#express.static) serves static assets such as HTML files, images, and so on.
- [express.json](http://www.expressjs.com.cn/en/4x/api.html#express.json) parses incoming requests with JSON payloads. **NOTE: Available with Express 4.16.0+**
- [express.urlencoded](http://www.expressjs.com.cn/en/4x/api.html#express.urlencoded) parses incoming requests with URL-encoded payloads. **NOTE: Available with Express 4.16.0+**

### **8.5 Third-party middleware** ###

Install the Node.js module for the required functionality, then load it in your app at the **application level** or at the **router level.**

```bash
$ npm install cookie-parser
```

```js
var express = require('express')
var app = express()
var cookieParser = require('cookie-parser')

// load the cookie-parsing middleware
app.use(cookieParser())
```

**For a partial list of third-party middleware functions that are commonly used with Express, see: [Third-party middleware](http://www.expressjs.com.cn/resources/middleware.html).**

## 9. Error Handling ##

[Error Handling](http://www.expressjs.com.cn/guide/error-handling.html)

Express comes with a default error handler so you don’t need to write your own to get started.

### 9.1 Catching Errors ###

***sync***

路由处理程序和中间件内的同步代码中发生的错误不需要额外的工作。

Errors that occur in synchronous code inside route handlers and middleware require **no extra work**. If synchronous code throws an error, then Express will catch and process it. For example:

```javascript
app.get("/", function (req, res) {
  throw new Error("BROKEN"); // Express will catch this on its own.
});
```

***async***

对于由路由处理程序和中间件调用的异步函数返回的错误，***您必须将它们传递给`next()`函数***，Express将捕获并处理它们。

For errors returned from asynchronous functions invoked by route handlers and middleware, you must pass them to the `next()`function, where Express will catch and process them. For example:

```javascript
app.get("/", function (req, res, next) {
  fs.readFile("/file-does-not-exist", function (err, data) {
    if (err) {
      next(err); // Pass errors to Express.
    }
    else {
      res.send(data);
    }
  });
});
```

### 9.2 The default error handler ###

Express comes with a built-in error handler that takes care of any errors that might be encountered in the app. This default error-handling middleware function is **added at the end of the middleware function stack.**

Express附带了一个内置的错误处理程序，可以处理应用程序中可能遇到的任何错误。此缺省错误处理中间件功能添加在中间件功能堆栈的末尾。

**如果您将错误传递给`next()`并且您没有在自定义错误处理程序中处理它，它将由内置错误处理程序处理; 错误将通过堆栈跟踪写入客户端。堆栈跟踪不包含在生产环境中。**

>  将环境变量设置`NODE_ENV`为`production`，以在生产模式下运行应用程序。

### 9.3 Writing error handlers ###

对于组织（和更高级别的框架）目的，您可以定义多个错误处理中间件函数，就像使用常规中间件函数一样。

Define error-handling middleware functions in the same way as other middleware functions, except error-handling functions have four arguments instead of three. You define error-handling middleware last, after other `app.use()` and routes calls; for example:

```javascript
var bodyParser = require('body-parser')
var methodOverride = require('method-override')

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use(logErrors)
app.use(clientErrorHandler)
app.use(errorHandler)
app.use(function (err, req, res, next) {
  // logic
})
```

> If you pass anything to the `next()` function (except the string `'route'`), **Express regards the current request as being an error and will skip any remaining non-error handling routing and middleware functions.** If you want to handle that error, you’ll have to create an error-handling route as described in the next section.

## 其他 ##

### [文件上传](http://www.runoob.com/nodejs/nodejs-express-framework.html) ###

app.use(multer({ dest: '/tmp/'}).array('image'));

```js
var express = require('express');
var app = express();
var fs = require("fs");
 
var bodyParser = require('body-parser');
var multer  = require('multer');
 
app.use('/public', express.static('public'));
app.use(bodyParser.urlencoded({ extended: false }));
app.use(multer({ dest: '/tmp/'}).array('image'));
 
app.get('/index.htm', function (req, res) {
   res.sendFile( __dirname + "/" + "index.htm" );
})
 
app.post('/file_upload', function (req, res) {
 
   console.log(req.files[0]);  // 上传的文件信息
 
   var des_file = __dirname + "/" + req.files[0].originalname;
   fs.readFile( req.files[0].path, function (err, data) {
        fs.writeFile(des_file, data, function (err) {
         if( err ){
              console.log( err );
         }else{
               response = {
                   message:'File uploaded successfully', 
                   filename:req.files[0].originalname
              };
          }
          console.log( response );
          res.end( JSON.stringify( response ) );
       });
   });
})
 
var server = app.listen(8081, function () {
 
  var host = server.address().address
  var port = server.address().port
 
  console.log("应用实例，访问地址为 http://%s:%s", host, port)
 
})
```



### 注意 ###

（1）、`app.all('/', func)` 和 `app.use('/', router)` 和 `app.use(func)` 的区别

（2）、`router.use('/', func)` 和 `router.use(func)` 和 `router.use('/', func)` 

> `app.get('/', func)` 不用 `next()` 的话不会阻断后面的路由处理

