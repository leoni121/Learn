[TOC]

## 1. 传统的软件开发流程模型 ##

![](./img/软件开发流程.png)

> ***运行和维护***并不是串行关系，也并非绝对的并行关系。维护贯穿从编码到运行的整个流程。
>
> 上图展示的软件开发模型中，这 ***求分析和设计阶段，*** 两个阶段具体到前端开发领域，更恰当的称谓应该是**功能需求分析和UI设计**，分别由产品经理和UI工程师完成。**至于API需求分析和API设计，应该包括在编码阶段**。

## 2. 作用 ##

1. 工程化要解决的是如何提高**整个系统生产效率**
2. 具体到前端工程化，面临的问题是如何提高**编码->测试->维护**阶段的生产效率。

## 3. 前端工程化面临的问题 ##

> 要解决前端工程化的问题，可以从两个角度入手：**开发和部署**。

### 3.1 ***开发角度*** ###

要解决的问题包括：

1. 提高开发生产效率；
2. 降低维护难度。

这两个问题的**解决方案**有两点：

1. 制定**开发规范**，提高团队协作能力；
2. 分治。软件工程中有个很重要的概念叫做**模块化开发**其中心思想就是分治。
   1. 分支管理
   2. 模块管理

### 3.2 ***部署角度*** ###

要解决的问题主要是资源管理，包括：

1. 代码审查；
2. 压缩打包；
3. 增量更新；
4. 单元测试；

要解决上述问题，需要引入**构建/编译阶段**。

## 4. 前端工程化面临的问题-解决 ##

###  4.1 开发规范 ###

开发规范的目的是统一团队成员的编码规范，便于团队协作和代码维护。开发规范没有统一的标准，每个团队可以建立自己的一套规范体系。

> ***eslint规范***

### 4.2 模块/组件化开发 ###

>  组件（component）和模块（module）是两个不同的概念。两者的区别主要在**颗粒度**方面。
>
>  ***模块化相关 可见 [文件夹-模块化-记录.md](./模块化/记录.md)*** 

**模块/组件化区别**

module侧重的是对属性的封装，重心是在设计和开发阶段，不关注runtime的逻辑。module是一个白盒；而component是一个可以独立部署的软件单元，面向的是runtime，侧重于产品的功能性。component是一个黑盒，内部的逻辑是不可见的。

### 4.3 构建&编译 ###

构建可以分为工具层面和平台层面的功能：

**工具层面**

1. 预编译，包括es6/7语法转译、css预编译器处理、spirit图片生成；
2. 依赖打包；
3. 资源嵌入；
4. 文件压缩；
5. hash指纹；
6. 代码审查；
7. 模板构建。

**平台层面**

1. 文件监听，动态编译；
2. mock server。

## 5.  总结 ##

一个完整的前端工程体系应该包括：

1. 统一的开发规范；
2. 组件化开发；
3. 构建流程。

**开发规范和组件化开发**面向的开发阶段，宗旨是提高团队协作能力，提高开发效率并降低维护成本。

**构建工具和平台**解决了web产品一系列的工程问题，旨在提高web产品的性能表现，提高开发效率。

> **所谓的压缩打包等为了性能做出的构建，其实是受限于客户端本身。任何架构也好，策略也好，都是对当前的一种解决方案，并不是一条条铁律。脱离了时代，任何技术讨论都没有意义。**



## OTHER

### 1. 需要解决的问题

- 扩展 javascript 、html、css 本身的语言能力
- 解决重复工作
- 模板化、模块化
- 解决功能复用和变更问题
- 解决开发和产品环境差异问题
- 解决发布流程问题

## 2. 何为工程化

> 所有能降低成本，并且能提高效率的事情的总称为工程化。

良好的工程化，能降低沟通成本，实现更好的协同，节省开发和测试人员的重复劳动，降低发布的常见问题等等，经过有效实践，工程化的推广还能极大地减少加班的时间。

## 3. 怎么做

#### 规范化

1. 文档。需求文档、设计文档、系统设计、测试单、项目报告。
2. 工具。开发语言选型，开发工具，协同工具，测试工具，发布工具。
3. 代码规范。javascript，css，html，技术文档。
4. 质量规范。功能方便，是否可拓展，是否满足 RESTFul，是否安全性满足

#### 流程化

- 软件开发常见流程
- 职责和协同
- 目标明确的版本计划
- 敏捷开发

#### 自动化

- 流程的自动化。即人员协同的自动化
- 代码开发自动化，去掉重复劳动
- 自动化单元测试
- UI/API/兼容性 自动化测试
- 自动化部署
- 自动化问题反馈