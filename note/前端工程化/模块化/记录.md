[TOC]

## 1. vue项目实现按需加载的3种方式 ##

[参考-博客](https://segmentfault.com/a/1190000011519350)



### 1.1 vue异步组件技术 ###

* vue-router配置路由，使用vue的[异步组件](https://cn.vuejs.org/v2/guide/components.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)技术，可以实现按需加载。

但是，这种情况下***一个组件生成一个js文件***。
举例如下：

```js
{
    path: '/promisedemo',
    name: 'PromiseDemo',
    component: resolve => require(['../components/PromiseDemo'], resolve)
}
```

### 1.2 es提案的import() ###

- 推荐使用这种方式(需要webpack > 2.4)
- webpack官方文档：[webpack中使用import()](https://doc.webpack-china.org/guides/code-splitting#-dynamic-imports-)
  vue官方文档：[路由懒加载(使用import())](https://router.vuejs.org/zh-cn/advanced/lazy-loading.html)

***指定了相同的webpackChunkName，会合并打包成一个js文件。***

vue-router配置路由，代码如下：

```js
// 没有指定webpackChunkName，每个组件打包成一个js文件。
...
// 指定了相同的webpackChunkName，会合并打包成一个js文件。
const ImportFuncDemo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')
```

### 1.3 webpack提供的require.ensure() ###

- vue-router配置路由，使用webpack的[require.ensure](https://doc.webpack-china.org/api/module-methods#require-ensure)技术，也可以实现按需加载。

这种情况下，***多个路由指定相同的chunkName，会合并打包成一个js文件。***
举例如下：



```
        {
            path: '/promisedemo',
            name: 'PromiseDemo',
            component: resolve => require.ensure([], () => resolve(require('../components/PromiseDemo')), 'demo')
        },
        {
            path: '/hello',
            name: 'Hello',
            // component: Hello
            component: resolve => require.ensure([], () => resolve(require('../components/Hello')), 'demo')
        }
```

## 2. 模块化思想 ##

### 2.1 什么是模块? ###

- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。
- 一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。

### 2.2 模块化好处 ###

- 避免变量污染，命名冲突
- 提高代码复用率
- 提高维护性
- 依赖关系的管理
- 更好的分离，按需加载

### 2.3 演变过程 ###

1. 全局function模式 ：将不同的功能封装成不同的全局函数

   - 编码: 将不同的功能封装成不同的全局函数
   - 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

2. namespace模式 : 简单对象封装

   - 作用: 减少了全局变量，解决命名冲突
   - 问题: 数据不安全(外部可以直接修改模块内部的数据)

3. IIFE模式：匿名函数自调用(闭包)

   - 作用: 数据是私有的, 外部只能通过暴露的方法操作
   - 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
   - 问题: 如果当前这个模块依赖另一个模块怎么办?

4. IIFE模式增强 : 引入依赖

5. commonJS规范

   > **加载某个模块，其实是加载该模块的module.exports属性**。

   Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**

   (2)特点

   - 所有代码都运行在模块作用域，不会污染全局作用域。
   - 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
   - *模块加载的顺序，按照其在代码中出现的顺序。*

   (3)基本语法

   - 暴露模块：`module.exports = value`或`exports.xxx = value`
   - 引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

   > **require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**

   (4)模块的加载机制

   **CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**。

6. AMD

   Asynchronous Module Definition，中文名是异步模块。它是一个在浏览器端模块化开发的规范，由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。

   requireJS主要解决两个问题：

   - 多个js文件可能有依赖关系，***被依赖的文件需要早于依赖它的文件加载到浏览器***。
   - ***js加载的时候浏览器会停止页面渲染***，加载文件愈多，页面失去响应的时间愈长。

   > 缺点：**首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！**

   **AMD推崇的是依赖前置**，被提前罗列出来并会被提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块。

7. CMD

   CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；CMD推崇依赖就近

8. ES6
   **ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。**ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。

### 2.4 AMD与CMD区别 ###

[参考-博客](https://www.cnblogs.com/code-klaus/p/9011911.html)

[参考-知乎-玉伯](https://www.zhihu.com/question/20351507/answer/14859415)

***AMD***  在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。

***CMD***  加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。
这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。

***区别概括***

- 对于依赖的模块，AMD 是**提前执行**，CMD 是**延迟执行**。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
- CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。

### 2.5 ES6 模块与 CommonJS 模块的差异 ###

[参考-博客](http://web.jobbole.com/95559/)

- **CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。
- **CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。