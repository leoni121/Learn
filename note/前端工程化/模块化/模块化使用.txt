** https://www.cnblogs.com/tian-xie/p/7754186.html

** export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
    ———— http://es6.ruanyifeng.com/#docs/module

** import命令输入的变量都是只读的，属性可以成功改写（有点const的赶脚），并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。

** export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新

** export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后
   // 正确
   export var a = 1;

   // 正确
   var a = 1;
   export default a;

   // 错误
   export default var a = 1;

** export 与 import 的复合写法
    ———— http://es6.ruanyifeng.com/#docs/module
    export { foo, bar } from 'my_module';
    // 可以简单理解为
    import { foo, bar } from 'my_module';
    export { foo, bar };
    export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是 相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar

** commonJs 与 ES6
    CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
    CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

** 输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。

** CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。

** // even.js
   var odd = require('./odd');
   var counter = 0;
   exports.counter = counter;
   exports.even = function (n) {
     counter++;
     return n == 0 || odd(n - 1);
   }

   // odd.js
   var even = require('./even').even;
   module.exports = function (n) {
     return n != 0 && even(n - 1);
   }
    结果如下
   function even (n) {
     counter++;
     return n == 0 || odd(n - 1);
   }
   function odd (n) {
    return n != 0 && even(n - 1);
  }