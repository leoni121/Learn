[TOC]
## webpack4 见 note 文件夹下的MyBlog文件夹下



## webpack 原理
https://segmentfault.com/a/1190000015088834
    如何实现一个简单的webpack
        =》读取文件分析模块依赖
        =》对模块进行解析执行(深度遍历)
        =》针对不同的模块使用相应的loader
        =》编译模块，生成抽象语法树AST。
        =》循环遍历AST树，拼接输出js。



## webpack 打包文件教学
https://www.jianshu.com/p/e24ed38d89fd



## 描述一下index.html 中的运行
    common 得到全局的 webpackJson 该函数相当于把请他模块的 函数给放入 modules这个变量中，所有的模块的函数共有一个modules， 其他的流程和单入口文件一样



## Loader
https://segmentfault.com/a/1190000015088834（参考）
    （1）能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。
    （2）loader原理
       在解析对于文件，会自动去调用响应的loaderloader 本质上是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成是 JS 代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。webpack会按照从右到左的顺序执行loader。



## chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。




## webpack为什么能把任何形式的资源都视作模块呢？因为loader机制。不同的资源采用不同的loader进行转换。CMD、AMD 、import、css 、等都有相应的loader去进行转换。那为什么我们平时写的es6的模块机制，不用增加import的loader呢。因为我们使用了babel把import转换成了require。
elrc 中，babel设置 module: false, 避免babel将模块转换为成 CommonJS规范。引入模块包也必须符合ES6规范的。如下 babelrc代码


## tree-shaking CSS  （purifycss-webpack purify-css）
	配置了paths，主要是需找html模板，pruifycss会根据这个配置会遍历你的文件，查找哪些css被使用了。


## webpack Babel 以及相关的配置
https://www.jianshu.com/p/ce28ceddda72


## module.rules 中的 loader 和 use
https://www.liangzl.com/get-article-detail-8022.html


## html-webpack-plugin配置
https://www.cnblogs.com/wonyun/p/6030090.html


## vue 中的 .babelrc 理解
https://www.cnblogs.com/ye-hcj/p/7071850.html


## extract-text-webpack-plugin 的使用及安装 ,该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象;
https://www.cnblogs.com/dyx-wx/p/6529447.html


## webpack配置中devtool项加不加#有什么区别？———— https://segmentfault.com/q/1010000011701354


## hash码 和 clean-webpack-plugin
https://www.jianshu.com/p/dd67a3b64b62


## vue 里面没有clean-webpack-plugin怎么实现清除相关内容
	chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk
	修改css相应的chunkhash不变，修改js变，此时无clean-webpack-plugin插件的话会导致文件混乱（多个具有同样[name]的文件）


## webpack 默认 访问 contentBase 下的index.html(如： localhost:8080 => localhost:8080/index.html =>)


## webpack 更改外部引入的css后 提取出来的css的chunkhash没有变？


## 热更新 和 chunkhash不能同时使用
https://segmentfault.com/q/1010000011438869/a-1020000011441168


## webpack devServer 不配置热更新保存的时候也能刷新，但是会刷新整个页面


## 背景图引入
	background: url(~@/img/1.jpg);


## output.publicPath 和 devServer.publicPath 等路径问题
	1.output.path
		output 目录对应一个绝对路径
	2.output.publicPath
https://www.webpackjs.com/configuration/output/#output-publicpath
	https://blog.csdn.net/u012193330/article/details/83310924


##  1. dev
		js => name.js
	2. port
		js => name.[chunkhash].js


## 没有一下代码会出现页面刷新
	function accept(m) {
		if (m.hot) {
			m.hot.accept();
		}
	}


##  new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify('*****')
      }), 作用

	https://www.cnblogs.com/usebtf/p/9912413.html


## webpack 公共部分提取 CommonsChunkPlugin
	分离对象：基础库文件，公共文件，webpack运行文件

https://blog.csdn.net/a4_9527/article/details/81192136 （基础）

https://www.cnblogs.com/joyco773/p/9050913.html （base）

https://segmentfault.com/a/1190000012828879 （vue疑惑）


## 提取css 可以防止出现无样式的界面


**如果使用style-loader将样式添加到js文件中，在编写样式的时候可以享受热更新的效果，如果使用extract-text-webpack-plugin 将样式提取，此组件并不支持热更新。只会重新打包但是并不会刷新页面。
官方建议在开发环境中关闭ExtractText组件。


## 热更新

https://www.cnblogs.com/liang1100/p/8457701.html#undefined

https://blog.csdn.net/xum222222/article/details/79889793


## glob
	在webpack中对文件的路径处理非常之方便，比如当搭建多页面应用时就可以使用glob对页面需要打包文件
	的路径进行很好的处理。


## TSCS 项目因为最开始项目搭建思路的问题导致，相应的页面刷新之后会回到最开始的样子
	***********## 
	***********## 
	***********## 
	***********## 


## webpack 可以开启GZip 但是也需要服务器开启


## hash chunkhash contenthash

https://www.jb51.net/article/132275.htm


## postcss css后处理
	autoprefixer-loader（三年前更新） =》 Please use postcss-loader instead of autoprefixer-loader


## mini-css-extract-plugin 和 extract-text-webpack-plugin 不和style-loader 一起使用
