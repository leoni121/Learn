[TOC]

## 1. url-loader 和 file-loader 的区别及使用 ##

url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader

url-loader工作分两种情况：

1. 文件大小小于limit参数，url-loader将会把文件转为DataURL。

- 文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。因此我们只需要安装url-loader即可。
>小提示： webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。 file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件

下面例子涉及到了4个参数：`limit`、`name`、`outputPath`、`publicPath`，file-loader相关的是`name`、`outputPath`和`outputPath`。下面解释一下这3个参数

1. `name`表示输出的文件名规则，如果不添加这个参数，输出的就是默认值：文件哈希。加上[path]表示输出文件的相对路径与当前文件相对路径相同，加上[name].[ext]则表示输出文件的名字和扩展名与当前相同。加上[path]这个参数后，打包后文件中引用文件的路径也会加上这个相对路径。

- `outputPath`表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。比如outputPath=img/，图片被打包时，就会在输出文件夹下新建（如果没有）一个名为img的文件夹，把图片放到里面。

- `publicPath`表示打包文件中引用文件的路径前缀，如果你的图片存放在CDN上，那么你上线时可以加上这个参数，值为CDN地址，这样就可以让项目上线后的资源引用路径指向CDN了。

    ```js
    module: {  
            rules: [  
                {  
                    test: /\.css$/,  
                    use: ['style-loader', 'css-loader']  
                },  
                {  
                    test: /\.jpeg$/,  
                    use: 'url-loader?limit=1024&name=[path][name].[ext]&outputPath=img/&publicPath=output/',  
                }  
          	  ]  
    	} 
    ```

    



## 2. webpack-dev-server和webpack-dev-middleware的区别 ##

[参考地址1-博客](https://www.cnblogs.com/wangpenghui522/p/6826182.html)， [参考地址2-官网](https://www.webpackjs.com/guides/development/)

### 2.1 webpack-dev-server ###

`webpack-dev-server`实际上相当于启用了一个`express`的`Http服务器+调用webpack-dev-middleware`。它的作用主要是用来伺服资源文件。这个`Http服务器`和`client`使用了`websocket`通讯协议，原始文件作出改动后，`webpack-dev-server`会用webpack实时的编译，再用webpack-dev-middleware将webpack编译后文件会输出到内存中。适合纯前端项目，很难编写后端服务，进行整合。

当使用 webpack dev server 和 Node.js API 时，不要将 dev server 选项放在 webpack 配置对象(webpack config object)中。而是，在创建选项时，将其作为第二个参数传递。例如：

```js
new WebpackDevServer(compiler, options)
```

想要启用 HMR，还需要修改 webpack 配置对象，使其包含 HMR 入口起点。`webpack-dev-server` package 中具有一个叫做 `addDevServerEntrypoints` 的方法，你可以通过使用这个方法来实现。这是关于如何使用的一个小例子：

**dev-server.js**

```javascript
const webpackDevServer = require('webpack-dev-server');
const webpack = require('webpack');

const config = require('./webpack.config.js');
const options = {
  contentBase: './dist',
  hot: true,
  host: 'localhost'
};

webpackDevServer.addDevServerEntrypoints(config, options);
const compiler = webpack(config);
const server = new webpackDevServer(compiler, options);

server.listen(5000, 'localhost', () => {
  console.log('dev server listening on port 5000');
});
```

> *如果你在* [使用 `webpack-dev-middleware`](https://www.webpackjs.com/guides/development#using-webpack-dev-middleware)*，可以通过* [`webpack-hot-middleware`](https://github.com/webpack-contrib/webpack-hot-middleware) *package 包，在自定义开发服务下启用 HMR。*

### 2.2 webpack-dev-middleware ###

[配置参考](https://segmentfault.com/a/1190000011761306)

webpack-dev-middleware输出的文件存在于内存中。你定义了 webpack.config，webpack 就能据此梳理出entry和output模块的关系脉络，而 webpack-dev-middleware 就在此基础上形成一个文件映射系统，每当应用程序请求一个文件，它匹配到了就把内存中缓存的对应结果以文件的格式返回给你，反之则进入到下一个中间件。

因为是内存型文件系统，所以重建速度非常快，很适合于开发阶段用作静态资源服务器；因为 webpack 可以把任何一种资源都当作是模块来处理，因此能向客户端反馈各种格式的资源，所以可以替代HTTP 服务器。事实上，大多数 webpack 用户用过的 webpack-dev-server 就是一个 express＋webpack-dev-middleware 的实现。二者的区别仅在于 webpack-dev-server 是封装好的，除了 webpack.config 和命令行参数之外，很难去做定制型开发。而 webpack-dev-middleware 是中间件，可以编写自己的后端服务然后把它整合进来，相对而言比较灵活自由。

```js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

// Tell express to use the webpack-dev-middleware and use the webpack.config.js
// configuration file as a base.
app.use(webpackDevMiddleware(compiler, {
  publicPath: config.output.publicPath
}));

// Serve the files on port 3000.
app.listen(3000, function () {
  console.log('Example app listening on port 3000!\n');
});
```

### 2.3 webpack-hot-middleware ###

是一个结合webpack-dev-middleware使用的middleware，它可以实现浏览器的无刷新更新（hot reload），这也是webpack文档里常说的HMR（Hot Module Replacement）。HMR和热加载的区别是：热加载是刷新整个页面。启用 HMR也可以通过更新 [webpack-dev-server](https://github.com/webpack/webpack-dev-server) 的配置，和使用 webpack 内置的 HMR 插件。



## 3. NamedModulesPlugin 和 HashedModuleIdsPlugin 的区别及使用 ##

### 3.1 NamedModulesPlugin ###

[参考](https://www.jianshu.com/p/8499842defbe)

> 当开启 [HMR](https://www.webpackjs.com/guides/hot-module-replacement) 的时候使用该插件会显示模块的相对路径，建议用于开发环境。

这个插件的作用是在*热加载时直接返回更新文件名*，而不是文件的id。

要这种效果

```js
[HMR] Updated modules:
[HMR]  - ./example.js
[HMR]  - ./hmr.js
[HMR] Update applied.
```

而不是这样

```js
[HMR] Updated modules:
[HMR]  - 39
[HMR]  - 40
[HMR] Update applied.
```

具体使用就是这样

```js
plugin: [
    new webpack.NamedModulesPlugin(),
]
```

### 3.2 HashedModuleIdsPlugin ###

[参考-官网](https://www.webpackjs.com/plugins/hashed-module-ids-plugin/)

> 该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。

该插件支持以下参数：

- `hashFunction`: 散列算法，默认为 'md5'。支持 Node.JS [`crypto.createHash`](https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm_options) 的所有功能。
- `hashDigest`: 在生成 hash 时使用的编码方式，默认为 'base64'。支持 Node.js [`hash.digest`](https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding) 的所有编码。
- `hashDigestLength`: 散列摘要的前缀长度，默认为 4。

**用法**

```js
new webpack.HashedModuleIdsPlugin({
  hashFunction: 'sha256',
  hashDigest: 'hex',
  hashDigestLength: 20
})
```

### 5.3 使用场景 ###

[参考-官网](https://www.webpackjs.com/plugins/hashed-module-ids-plugin/)

`output`如下设置:

```js
output: {
    filename: '[name].[chunkhash].js',
    path: path.resolve(__dirname, 'dist')
}

```

公共依赖没有变,公共文件的hash 改变?

每个 [`module.id`](https://www.webpackjs.com/api/module-variables#module-id-commonjs-) 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。

> [`NamedModulesPlugin`](https://www.webpackjs.com/plugins/named-modules-plugin)，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 [`HashedModuleIdsPlugin`](https://www.webpackjs.com/plugins/hashed-module-ids-plugin)，推荐用于生产环境构建



## 4. webpack-merge ##

[参考-github](https://github.com/survivejs/webpack-merge)

**webpack-merge**提供了一个`merge`连接数组并合并创建新对象的对象的函数。如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值包装在函数中。

这种行为在配置webpack时特别有用，尽管它有超出它的用途。无论何时需要合并配置对象，**webpack-merge**都可以派上用场。

还有一个特定于webpack的合并变体`merge.smart`，它可以考虑webpack特性（即，它可以展平加载器定义）。

**标准合并 merge(...configuration | [...configuration])**

`merge`是API的核心，也是最重要的想法。除非您想进一步定制，否则通常这就是您所需要的。

```js
//默认API 
module.exports =  merge（object1，object2，object3， ...）;

//您可以直接传递对象数组。
//这适用于所有可用的功能。
module.exports =  merge（[object1，object2，object3]）;
```



## 5. ExtractTextWebpackPlugin 和 MiniCssExtractPlugin ##

[参考-官网](https://www.webpackjs.com/plugins/extract-text-webpack-plugin/), [项目webpack3 迁移到 webpack4 可参考](https://blog.csdn.net/lqlqlq007/article/details/83865176)

### 5.1 MiniCssExtractPlugin  ###

[参考-官网](https://www.npmjs.com/package/mini-css-extract-plugin)

> English: This plugin should be used only on `production` builds without `style-loader` in the loaders chain, especially if you want to have HMR in `development`.
>
> 中：在使用时不能喝  `  style-loader`共存，只用于生产环境

**webpack.config.js**

```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const devMode = process.env.NODE_ENV !== 'production'
 
module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      // Options similar to the same options in webpackOptions.output
      // both options are optional
      filename: devMode ? '[name].css' : '[name].[hash].css',
      chunkFilename: devMode ? '[id].css' : '[id].[hash].css',
    })
  ],
  module: {
    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          devMode ? 'style-loader' : MiniCssExtractPlugin.loader,
          'css-loader',
          'postcss-loader',
          'sass-loader',
        ],
      }
    ]
  }
}
```

### 5.2 ExtractTextWebpackPlugin ###

[参考-官网](https://www.webpackjs.com/plugins/extract-text-webpack-plugin/)

```js
module: {
    rules: [
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: "style-loader",
          use: "css-loader"
        })
      }
    ]
  },
```

## 6 CommonsChunkPlugin ##

`CommonsChunkPlugin` 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 `chunk` 的公共模块。

> CommonsChunkPlugin 已经从 webpack v4 legato 中移除。想要了解在最新版本中如何处理 chunk，请查看 [SplitChunksPlugin](https://www.webpackjs.com/plugins/split-chunks-plugin/)。

**使用**

```js
 plugina: [
     new webpack.optimize.CommonsChunkPlugin({
        name: 'vendor'
      }),
      new webpack.optimize.CommonsChunkPlugin({
        name: 'manifest'
      })
 ]
```

> *注意，引入顺序在这里很重要。*`CommonsChunkPlugin` *的* `'vendor'` *实例，必须在* `'manifest'` *实例之前引入。*

