[TOC]

###  1. XSS （Cross Site Scripting） ###

#### 1.1 概述 ####

**跨站脚本攻击**(`Cross Site Scripting`)，指恶意攻击者往Web页面里*插入恶意Script代码*，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。`xss`是**注入攻击**的一种，其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。

#### 1.2 攻击方式 ####

1. **反射型XSS**，也叫非持久型XSS，是指发生请求时，**XSS代码出现在请求URL中**，作为参数提交到服务器，服务器解析并响应。**响应结果中包含XSS代码，最后浏览器解析并执行**。
2. **存储型XSS**，也叫持久型XSS，**主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。）**，然后在下次请求页面的时候就不用带上XSS代码了。（**留言板**）
3. DOM XSS攻击不同于反射型XSS和存储型XSS，DOM XSS代码不需要服务器端的解析响应的直接参与，而是**通过浏览器端的DOM解析**。这完全是客户端的事情。 **DOM XSS代码的攻击发生的可能在于我们编写JS代码造成的**。我们知道eval语句有一个作用是将一段字符串转换为真正的JS语句，因此在JS中使用eval是很危险的事情，容易造成XSS攻击。避免使用eval语句。

#### 1.3 危害 ####

1. 通过document.cookie盗取cookie
2. 使用js或css破坏页面正常的结构与样式
3. **流量劫持**（通过访问某段具有window.location.href定位到其他页面），区别于网络劫持
4. Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使用户无法得到服务器响应。
5. **利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份** **执行一些管理动作**，或执行一些一般的如发微博、加好友、发私信等操作。
6. 利用可被攻击的域受到其他域信任的特点，**以受信任来源的身份请求一些平时不允许的操作**，如进行不当的投票活动。

#### 1.4 防御 ####

1. 对重要的cookie设置httpOnly, 防止客户端通过document.cookie读取cookie。服务端可以设置此字段。
   [Cookie中的httponly的属性和作用](<https://blog.csdn.net/qq_38553333/article/details/80055521>)

   ***作用***

   通过js脚本将无法读取到cookie信息

   ***HttpOnly的设置样例***

   ```js
   response.setHeader("Set-Cookie", "cookiename=httponlyTest;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly");
   
   //设置cookie
   response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly")
   
   //设置多个cookie
   response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly");
   response.addHeader("Set-Cookie", "timeout=30; Path=/test; HttpOnly");
   
   //设置https的cookie
   response.addHeader("Set-Cookie", "uid=112; Path=/; Secure; HttpOnly");
   ```

   ```java
   // 具体参数的含义再次不做阐述，设置完毕后通过js脚本是读不到该cookie的，但使用如下方式可以读取。
   Cookie cookies[]=request.getCookies();  
   ```

   

2. 输入数据的处理
   1. **编码**：不能对用户输入的内容都保持原样，**对用户输入的数据进行字符实体编码。**对于字符实体的概念可以参考文章底部给出的参考链接。
   2. **解码**：原样显示内容的时候必须解码，不然显示不到内容了。
   3. **过滤**：**把输入的一些不合法的东西都过滤掉，从而保证安全性。**如移除用户上传的DOM属性，如onerror，移除用户上传的Style节点，iframe, script节点等。



### 2. CSRF/XSRF （Cross-site request forgery） ###

**跨站请求伪造**，也被称为`One Click Attack`或者`Session Riding`，通常缩写为`CSRF`或者`XSRF`，是一种对网站的恶意利用。尽管听起来像跨站脚本（`XSS`），但它与`XSS`非常不同，通俗说：`XSS`有脚本的参与，黑客构造好各种各样功能的脚本让你来触发从而利用你的信息。**而`CSRF`则通过伪装成受信任用户的请求即借你的手触发某些操作。**与`XSS`攻击相比，`CSRF`攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比`XSS`更具危险性。通过 `XSS` 来实现 `CSRF` 易如反掌，黑客可以通过 `XSS` 或链接欺骗等途径，让用户在登陆过的浏览器端发起用户所不知道的请求。对于设计不佳的网站，一条正常的链接都能造成 `CSRF`。

> CSRF攻击的一般是由服务端解决

#### 2.1 攻击步骤 ####

要完成一次CSRF攻击，受害者必须依次完成两个步骤：

1. 登录受信任网站A，并在本地生成Cookie。
2. 在不登出A的情况下，访问危险网站B。

> CSRF被伪造的请求可以是任何来源，而非一定是站内。伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

#### 2.2 攻击方式 ####

1. GET

最简单的CSRF攻击：

- 用户Alice登录访问某有csrf漏洞的银行网站http://www.examplebank.com。
- Alice被某些信息诱导访问危险网站B。
- 危险网站B上有一个<img>标签 `<img src="http://www.examplebank.com/from=Alice&amount=100&to=Bob">`
- 这个img标签的src不指向图片，而是一个http请求，这个请求让银行服务器从Alice转100到Bob账户上，由于Alice已经登录，浏览器发请求时候会带上cookie骗取服务器信任得到响应。
- 这样Alice的钱就被悄悄转走了。

```html
<a href="http:xxx.com/xxx">点击</a>
<img src="http:xxx.com/xxx">
```

2. ## post攻击 ##

危险网站伪造一个隐藏的表单，在onload事件中，触发表单的提交事件。 为防止跳转，可以加一个隐藏的iframe，在iframe中处理提交的请求。

![](./img/xsrf-post.png)

#### 2.3 危害 ####

- 盗取用户资金（网上银行，购物）
- 冒充用户发帖（广告帖）
- 损坏网站名誉

#### 2.4 防御 ####

[链接(最全)](https://blog.csdn.net/xiaoxinshuaiga/article/details/80766369)

1. **改良站内 API 的设计**

2. 在请求地址中添加 **token 并验证**

   要抵御 CSRF，关键在于在请求中**放入黑客所不能伪造的信息**，并且该信息不存在于 cookie 之中。**可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，**并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

3. **防止XSS注入**

4. iframe、ajax（这个不能跨域，得先 XSS）、Flash 内部发起请求（总是个大隐患）

5. 在 **HTTP 头中** **自定义属性并验证**

   这种方法**也是使用 token 并进行验证**，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

6. **HTTP Referer**

   根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。

   这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

   使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全

7. 重要的请求应该通过post方式进行（杜绝通过点击链接进行攻击）。

8. 禁止第三方网站带Cookies

### 3  XSS 和 CSRF/XSRF 的差异 ###

XSS有脚本的参与，黑客构造好**各种各样功能的脚本让你来触发**从而利用你的信息。而CSRF则通过**伪装成受信任用户的请求**即借你的手触发某些操作。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。



### 4. 前端安全总结 ###

[参考-博客](http://www.cnblogs.com/vajoy/p/4176908.html)

1. **资源枚举**

   遍历你站点所有可访问的目录，然后把一些常见的备胎文件名（比如“sql.bak”、“index-副本.html”）一个个都枚举一下，如果运气好枚举到了就直接下载。

2. **XXS**

3. **DOS攻击**
   拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。

4. **CSRF攻击**

5. **钓鱼攻击**
   指的是网站的伪造，比如**ta0bao.com**，然后在其中应用XSS等方式发起攻击。

6. **SQL注入**
   提交含有SQL操作语句的信息给后端，后端如果没有做好过滤就执行该语句，攻击者自然可以随意操纵该站点的数据库。

```js
	比如有一个图书馆站点book.com，你点进一本书的详情页面，其url是这样的：
	book.com/book?id=100
   说明这本书在数据库中的键值是100，后端收到url参数后就执行了数据库查询操作：
   select * from booktable where id='100'
   那么如果我们把url更改为
   book.com/book?id=100'or'1'='1
   那么数据库操作执行就变成了：
   select * from booktable where id='100'or'1'='1'
   从而取出了整个booktable 表单的全部数据。
```

7. **点击劫持**
   [web安全之点击劫持(clickjacking)](<https://blog.csdn.net/qq_32523587/article/details/79613768>)点击劫持，clickjacking，也被称为UI-覆盖攻击。这个词首次出现在2008年，是由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。
   它是通过覆盖不可见的框架误导受害者点击。
   虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。

   这种攻击利用了HTML中<iframe>标签的透明属性。