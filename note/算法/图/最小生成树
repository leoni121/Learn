** 最短路径联通所有点


** Prim （U已访问， G未访问）随便找个顶点，放入U中，找G中寻找顶点 到U的顶点最小路径的（重复）


** Kruskal  （V记录边， G记录点）依次寻找V中最小的边并且记录（G）改变的顶点，再找最小的边，看这个边的顶点是否在（G），不在的话记录顶点，重复
    最大连通点：
        // 获取
        function getBoos(Boos, i) {
            while(Boos[i] != 0)
                i = Boos[i];
            return i
        }

        // 生成
        m = getBoos....
        n = getBoos...
        Boos[min in m and n] = max min in m and m`

